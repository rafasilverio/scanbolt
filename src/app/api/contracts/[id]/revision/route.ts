import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { AIChange, Highlight } from '@/types/contract';
import OpenAI from 'openai';
import { v4 as uuidv4 } from 'uuid';

const openai = new OpenAI();

function recalculateIndices(
  items: Array<{ startIndex: number; endIndex: number }>, 
  oldContent: string, 
  newContent: string
): Array<{ startIndex: number; endIndex: number }> {
  // Create a mapping of old positions to new positions
  const diffMapping = new Map<number, number>();
  let oldPos = 0;
  let newPos = 0;

  while (oldPos < oldContent.length && newPos < newContent.length) {
    diffMapping.set(oldPos, newPos);
    
    // Move through both strings
    if (oldContent[oldPos] === newContent[newPos]) {
      oldPos++;
      newPos++;
    } else {
      // Find next matching character
      const nextMatchOld = oldContent.indexOf(newContent[newPos], oldPos);
      const nextMatchNew = newContent.indexOf(oldContent[oldPos], newPos);
      
      if (nextMatchOld >= 0 && (nextMatchNew < 0 || nextMatchOld < nextMatchNew)) {
        // Characters were deleted
        oldPos = nextMatchOld;
      } else if (nextMatchNew >= 0) {
        // Characters were added
        newPos = nextMatchNew;
      } else {
        // No match found, move both forward
        oldPos++;
        newPos++;
      }
    }
  }

  // Adjust indices based on the mapping
  return items.map(item => {
    const newStartIndex = diffMapping.get(item.startIndex) ?? 0;
    const newEndIndex = diffMapping.get(item.endIndex) ?? newContent.length;
    
    return {
      ...item,
      startIndex: newStartIndex,
      endIndex: newEndIndex
    };
  });
}

export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return new NextResponse('Unauthorized', { status: 401 });
    }

    // Get existing contract with current highlights and changes
    const existingContract = await prisma.contract.findUnique({
      where: { id: params.id }
    });

    if (!existingContract) {
      return NextResponse.json(
        { error: 'Contract not found' },
        { status: 404 }
      );
    }

    // Set status to under_review immediately
    await prisma.contract.update({
      where: { id: params.id },
      data: { status: 'under_review' }
    });

    // Parse existing arrays
    const existingHighlights: Highlight[] = JSON.parse(existingContract.highlights || '[]');
    const existingChanges: AIChange[] = JSON.parse(existingContract.changes || '[]');

    const { originalContent, changes, highlights } = await req.json();

    // Apply all changes to get intermediate content
    let intermediateContent = originalContent;
    const sortedChanges = [...(changes || [])].sort((a, b) => b.startIndex - a.startIndex);
    
    for (const change of sortedChanges) {
      intermediateContent = 
        intermediateContent.substring(0, change.startIndex) +
        change.suggestion +
        intermediateContent.substring(change.endIndex);
    }

    // Generate AI improvements
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: `You are a legal document expert. Analyze the provided contract and update it to suggest improvements generated by other lawers with the goal of making the contract more clear and concise.`
        },
        {
          role: "user",
          content: `Improve this contract and return a JSON response with:
- finalContent: the complete improved contract text
- improvements: array of new improvements with message, suggestion, startIndex, and endIndex
- addedClauses: array of new clauses with title, explanation, startIndex, and endIndex

Contract to improve: ${intermediateContent}`
        }
      ],
      temperature: 0.3,
      max_tokens: 4000,
      response_format: { type: "json_object" }
    });

    const aiContent = response.choices[0]?.message?.content;
    if (!aiContent) {
      throw new Error('Empty response from OpenAI');
    }

    let aiResponse;
    try {
      aiResponse = JSON.parse(aiContent);
    } catch (error) {
      console.error('Failed to parse AI response:', aiContent);
      throw new Error('Invalid AI response format');
    }

    // Process highlights and changes
    const adjustedExistingHighlights = recalculateIndices(
      existingHighlights,
      originalContent,
      aiResponse.finalContent
    );

    const adjustedExistingChanges = recalculateIndices(
      existingChanges,
      originalContent,
      aiResponse.finalContent
    );

    const newHighlights = [
      ...adjustedExistingHighlights,
      ...(aiResponse.improvements || []).map((improvement: any) => ({
        id: uuidv4(),
        type: 'improvement',
        message: improvement.message,
        suggestion: improvement.suggestion,
        startIndex: improvement.startIndex,
        endIndex: improvement.endIndex,
        createdAt: new Date().toISOString()
      }))
    ];

    const newChanges = [
      ...adjustedExistingChanges,
      ...sortedChanges.map(change => {
        const adjustedChange = recalculateIndices(
          [change],
          originalContent,
          aiResponse.finalContent
        )[0];
        
        return {
          ...adjustedChange,
          id: change.id || uuidv4(),
          appliedAt: new Date().toISOString()
        };
      })
    ];

    // Update contract with new content
    const revisionContract = await prisma.contract.update({
      where: { id: params.id },
      data: {
        content: aiResponse.finalContent,
        highlights: JSON.stringify(newHighlights),
        changes: JSON.stringify(newChanges),
        status: 'approved',
        updatedAt: new Date()
      }
    });

    return NextResponse.json({
      success: true,
      contract: {
        ...revisionContract,
        highlights: newHighlights,
        changes: newChanges,
        content: aiResponse.finalContent
      }
    });

  } catch (error) {
    console.error('Error in revision generation:', error);
    
    // Revert to original state on error
    await prisma.contract.update({
      where: { id: params.id },
      data: {
        status: 'under_review',
        updatedAt: new Date()
      }
    });

    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to generate revision' },
      { status: 500 }
    );
  }
}
