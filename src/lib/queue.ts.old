// [ARQUIVO ANTIGO] - Substituído pelo queue.common.js
// Mantido apenas para referência

import { Redis } from '@upstash/redis';

// Inicializar cliente Redis
const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

// Constante para o nome da fila
const QUEUE_KEY = 'contract-processing-queue';

// Tipo para os jobs na fila
export type ContractJob = {
  contractId: string;
  fileData: {
    buffer: string; // base64
    name: string;
    type: string;
    size: number;
  };
  userId: string;
  isPreview: boolean;
  tempId?: string;
  createdAt: number;
};

// Função para adicionar um job à fila
export async function addToQueue(job: Omit<ContractJob, 'createdAt'>): Promise<string> {
  const jobWithTimestamp: ContractJob = {
    ...job,
    createdAt: Date.now()
  };
  
  // Adiciona o job ao final da lista no Redis
  const jobId = await redis.rpush(QUEUE_KEY, JSON.stringify(jobWithTimestamp));
  
  console.log(`Job added to queue with ID: ${jobId}, contract: ${job.contractId}`);
  
  return jobId.toString();
}

// Função para obter o próximo job da fila (FIFO)
export async function getNextJob(): Promise<ContractJob | null> {
  // Obtém e remove o primeiro elemento da lista
  const jobData = await redis.lpop(QUEUE_KEY);
  
  if (!jobData) {
    return null;
  }
  
  try {
    const job = JSON.parse(jobData as string) as ContractJob;
    return job;
  } catch (error) {
    console.error('Error parsing job data:', error);
    return null;
  }
}

// Função para obter o status da fila
export async function getQueueStatus(): Promise<{ 
  length: number; 
  oldestJob: number | null;
  newestJob: number | null;
}> {
  // Obtém o tamanho atual da fila
  const queueLength = await redis.llen(QUEUE_KEY);
  
  // Se a fila estiver vazia, retorna valores padrão
  if (queueLength === 0) {
    return {
      length: 0,
      oldestJob: null,
      newestJob: null
    };
  }
  
  // Pega o primeiro job (mais antigo) sem removê-lo
  const oldest = await redis.lindex(QUEUE_KEY, 0);
  let oldestTimestamp: number | null = null;
  
  if (oldest) {
    try {
      const job = JSON.parse(oldest as string) as ContractJob;
      oldestTimestamp = job.createdAt;
    } catch (error) {
      console.error('Error parsing oldest job:', error);
    }
  }
  
  // Pega o último job (mais recente) sem removê-lo
  const newest = await redis.lindex(QUEUE_KEY, -1);
  let newestTimestamp: number | null = null;
  
  if (newest) {
    try {
      const job = JSON.parse(newest as string) as ContractJob;
      newestTimestamp = job.createdAt;
    } catch (error) {
      console.error('Error parsing newest job:', error);
    }
  }
  
  return {
    length: queueLength,
    oldestJob: oldestTimestamp,
    newestJob: newestTimestamp
  };
} 