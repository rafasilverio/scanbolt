<!-- Generated by SpecStory -->

# Timeout Issues and Async Contract Analysis Solution (2025-03-03 15:52:49)

_**User**_

Hey chat, eu estou enfrentando timeout ao analisar um contrato com IA ao subir para produção.

O que acha de deixarmos a parte da Analise de IA de fundo (via fila) já dentro da página do contrato? Com um loading até finalizar.

Se fizermos via Fila a etapa de analise que chamamos no @analyzeContract() dentro do @process.ts na linha 172, não resolveria?

Pensei em usar o upstash direto com o Vercel (até iniciei a implementação mas não finalizei).

O que você acha desta solução para evitar os problemas de timeout? Por favor analise com cuidado e me traga a melhor solução e forma de implementar sem quebrar o sistema atual.

Links de ajuda do Upstash Redis:
@https://upstash.com/docs/redis/quickstarts/nextjs-app-router 
@https://upstash.com/docs/redis/howto/vercelintegration 

---

_**Assistant**_

# Implementando Upstash Redis para processamento assíncrono de análise de contratos

Sua ideia de usar uma fila para processar a análise de IA em segundo plano é excelente para resolver o problema de timeout. O Upstash Redis é uma ótima escolha para implementar isso com Next.js, especialmente em produção na Vercel.

Vamos implementar uma solução que:
1. Coloca a tarefa de análise na fila Redis
2. Retorna imediatamente para o usuário com status "em processamento"
3. Processa a análise em segundo plano
4. Atualiza o status quando concluído

## Implementação

### 1. Primeiro, configure o Upstash Redis

```shell
npm install @upstash/redis
```

Adicione as variáveis de ambiente no seu `.env`:
```
UPSTASH_REDIS_REST_URL=<seu-url-do-upstash>
UPSTASH_REDIS_REST_TOKEN=<seu-token-do-upstash>
```

### 2. Crie um cliente Redis

```typescript:src/lib/redis.ts
import { Redis } from "@upstash/redis";

// Cria uma instância do Redis usando as variáveis de ambiente
export const redis = Redis.fromEnv();
```

### 3. Modifique o processamento do contrato

```typescript:src/lib/process.ts
// ... existing code ...
import { redis } from '@/lib/redis';

// ... existing code ...

export async function processContractInBackground(
  contractId: string, 
  file: File, 
  userId: string
) {
  try {
    // 1. Upload do arquivo para o Supabase
    const sanitizedFileName = sanitizeFileName(file.name);
    const uniqueFileName = `${Date.now()}-${sanitizedFileName}`;
    const buffer = await file.arrayBuffer();

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('contracts')
      .upload(uniqueFileName, buffer, {
        contentType: file.type,
        upsert: false
      });

    if (uploadError) throw uploadError;

    const { data: { publicUrl } } = supabase.storage
      .from('contracts')
      .getPublicUrl(uploadData.path);

    // 2. Extrair texto e coordenadas
    const { text, numPages, textCoordinates } = await extractTextContent(file);

    // 3. Primeira atualização: URL do arquivo e conteúdo
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        fileUrl: publicUrl,
        content: text,
        numPages: numPages,
        status: "processing" // Atualiza status para processing
      }
    });

    // 4. Adicionar à fila do Redis para processamento assíncrono
    await redis.lpush('contract-analysis-queue', JSON.stringify({
      contractId,
      userId,
      text,
      textCoordinates: Array.from(textCoordinates.entries())
    }));

    // Retorna imediatamente após colocar na fila
    return { success: true, status: "processing" };

  } catch (error) {
    console.error('Background processing error:', error);
    
    // Atualizar contrato com erro
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'error',
        metadata: {
          error: error instanceof Error ? error.message : 'Processing failed'
        }
      }
    });
    
    return { success: false, error: error instanceof Error ? error.message : 'Processing failed' };
  }
}

// Nova função para processar a fila
export async function processAnalysisQueue() {
  try {
    // Pega o próximo item da fila (sem remover)
    const queueItem = await redis.lindex('contract-analysis-queue', 0);
    
    if (!queueItem) {
      return { success: true, message: "No items in queue" };
    }
    
    const { contractId, userId, text, textCoordinates } = JSON.parse(queueItem);
    
    // Reconstruir o Map de coordenadas
    const coordsMap = new Map(textCoordinates);
    
    // Realizar a análise
    const analysisResult = await analyzeContract(text, coordsMap);
    
    // Atualizar o contrato com os resultados
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        issues: JSON.parse(JSON.stringify(analysisResult.issues)),
        suggestedClauses: JSON.parse(JSON.stringify(analysisResult.suggestedClauses)),
        status: "under_review",
        metadata: {
          updatedAt: new Date()
        }
      }
    });
    
    // Remover o item da fila após processamento bem-sucedido
    await redis.lpop('contract-analysis-queue');
    
    return { success: true, contractId };
    
  } catch (error) {
    console.error('Queue processing error:', error);
    
    // Não remover da fila em caso de erro para tentar novamente
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Queue processing failed' 
    };
  }
}
```

### 4. Crie uma API route para processar a fila

```typescript:src/app/api/process-queue/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { processAnalysisQueue } from '@/lib/process';

export const maxDuration = 300; // 5 minutos para funções serverless na Vercel

export async function POST(req: NextRequest) {
  try {
    // Verificar token de segurança (opcional, mas recomendado)
    const authHeader = req.headers.get('authorization');
    if (!authHeader || authHeader !== `Bearer ${process.env.QUEUE_SECRET_TOKEN}`) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const result = await processAnalysisQueue();
    return NextResponse.json(result);
  } catch (error) {
    console.error('Queue processing error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
```

### 5. Crie um componente para verificar o status do processamento

```typescript:src/components/ContractProcessingStatus.tsx
'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';

interface ContractProcessingStatusProps {
  contractId: string;
  initialStatus: string;
}

export default function ContractProcessingStatus({ 
  contractId, 
  initialStatus 
}: ContractProcessingStatusProps) {
  const [status, setStatus] = useState(initialStatus);
  const [loading, setLoading] = useState(initialStatus === 'processing');
  const router = useRouter();

  useEffect(() => {
    if (status !== 'processing') return;

    const checkStatus = async () => {
      try {
        const response = await fetch(`/api/contracts/${contractId}/status`);
        const data = await response.json();
        
        if (data.status !== 'processing') {
          setStatus(data.status);
          setLoading(false);
          router.refresh(); // Recarregar a página para mostrar os resultados
        }
      } catch (error) {
        console.error('Error checking contract status:', error);
      }
    };

    const interval = setInterval(checkStatus, 5000); // Verificar a cada 5 segundos
    return () => clearInterval(interval);
  }, [contractId, status, router]);

  if (!loading) return null;

  return (
    <div className="p-4 bg-blue-50 rounded-md mb-4">
      <div className="flex items-center">
        <div className="animate-spin mr-2 h-5 w-5 border-t-2 border-blue-500 rounded-full"></div>
        <p>Analisando seu contrato... Isso pode levar alguns minutos.</p>
      </div>
    </div>
  );
}
```

### 6. Crie uma API route para verificar o status do contrato

```typescript:src/app/api/contracts/[id]/status/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const contractId = params.id;
    
    const contract = await prisma.contract.findUnique({
      where: { id: contractId },
      select: { status: true }
    });
    
    if (!contract) {
      return NextResponse.json({ error: 'Contract not found' }, { status: 404 });
    }
    
    return NextResponse.json({ status: contract.status });
  } catch (error) {
    console.error('Error fetching contract status:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
```src/app/(protected)/contracts/[id]/page.tsx

### 7. Configure um worker para processar a fila

Você pode usar o Vercel Cron Jobs para processar a fila regularmente:

```typescript:src/app/api/cron/process-queue/route.ts
import { NextResponse } from 'next/server';
import { processAnalysisQueue } from '@/lib/process';

// Executar a cada minuto
export const config = {
  runtime: 'edge',
  regions: ['iad1'],
};

export async function GET() {
  try {
    // Processar até 5 itens da fila por execução
    let processed = 0;
    let result;
    
    for (let i = 0; i < 5; i++) {
      result = await processAnalysisQueue();
      if (!result.success || result.message === "No items in queue") {
        break;
      }
      processed++;
    }
    
    return NextResponse.json({ success: true, processed });
  } catch (error) {
    console.error('Cron job error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
```

### 8. Atualize a página do contrato para mostrar o status de processamento

```typescript:src/app/contracts/[id]/page.tsx
// Importe o componente de status
import ContractProcessingStatus from '@/components/ContractProcessingStatus';

// No seu componente de página:
export default async function ContractPage({ params }: { params: { id: string } }) {
  const contract = await getContract(params.id);
  
  return (
    <div>
      {/* Mostrar o status de processamento se necessário */}
      {contract.status === 'processing' && (
        <ContractProcessingStatus 
          contractId={contract.id} 
          initialStatus={contract.status} 
        />
      )}
      
      {/* Resto do conteúdo da página */}
    </div>
  );
}
```

## Configuração do Vercel Cron

No seu arquivo `vercel.json`, adicione:

```json
{
  "crons": [
    {
      "path": "/api/cron/process-queue",
      "schedule": "* * * * *"
    }
  ]
}
```

## Conclusão

Esta implementação resolve o problema de timeout ao:

1. Separar o upload e extração de texto (operações rápidas) da análise de IA (operação lenta)
2. Usar o Upstash Redis como fila para armazenar tarefas pendentes
3. Processar a análise de forma assíncrona via Cron Jobs
4. Atualizar a interface do usuário em tempo real quando a análise for concluída

A solução é escalável e funciona bem com a arquitetura serverless da Vercel. O usuário terá feedback imediato e poderá ver o progresso da análise sem enfrentar timeouts.

---

_**User**_

legal, como eu posso testa-lo?

---

_**Assistant**_

# Como testar a implementação da fila de processamento

Para testar sua implementação de processamento assíncrono com Upstash Redis, siga estes passos:

## 1. Configuração do ambiente

1. **Configure o Upstash Redis**:
   - Crie uma conta no [Upstash](https://upstash.com/) se ainda não tiver
   - Crie um novo banco de dados Redis
   - Copie as credenciais REST URL e REST TOKEN para seu arquivo `.env`

2. **Adicione as variáveis de ambiente**:
   ```
   UPSTASH_REDIS_REST_URL=seu-url-do-upstash
   UPSTASH_REDIS_REST_TOKEN=seu-token-do-upstash
   QUEUE_SECRET_TOKEN=um-token-secreto-para-sua-api
   ```

## 2. Teste local

1. **Inicie o servidor de desenvolvimento**:
   ```
   npm run dev
   ```

2. **Teste o fluxo completo**:
   - Faça upload de um contrato através da interface
   - Verifique se o status muda para "processing"
   - Observe o componente de loading aparecer

3. **Teste manual do processamento da fila**:
   - Acesse `http://localhost:3000/api/cron/process-queue` no navegador ou use uma ferramenta como Postman
   - Verifique os logs do servidor para confirmar que a fila está sendo processada
   - Observe se o status do contrato muda para "under_review" após o processamento

## 3. Teste dos componentes individuais

### Teste da adição à fila

```typescript
// Crie um arquivo de teste temporário
// src/app/api/test-queue/route.ts

import { NextResponse } from 'next/server';
import { redis } from '@/lib/redis';

export async function GET() {
  try {
    // Verificar o tamanho atual da fila
    const queueLength = await redis.llen('contract-analysis-queue');
    
    // Listar os itens na fila (apenas para teste)
    const queueItems = await redis.lrange('contract-analysis-queue', 0, -1);
    
    return NextResponse.json({ 
      success: true, 
      queueLength,
      queueItems: queueItems.map(item => JSON.parse(item))
    });
  } catch (error) {
    console.error('Queue test error:', error);
    return NextResponse.json({ error: String(error) }, { status: 500 });
  }
}
```

Acesse `http://localhost:3000/api/test-queue` para ver o conteúdo atual da fila.

### Teste do processador de fila

```typescript
// Crie um arquivo de teste temporário
// src/app/api/test-process/route.ts

import { NextResponse } from 'next/server';
import { processAnalysisQueue } from '@/lib/process';

export async function GET() {
  try {
    const result = await processAnalysisQueue();
    return NextResponse.json(result);
  } catch (error) {
    console.error('Process test error:', error);
    return NextResponse.json({ error: String(error) }, { status: 500 });
  }
}
```

Acesse `http://localhost:3000/api/test-process` para processar manualmente um item da fila.

## 4. Monitoramento em produção

Depois de implantar na Vercel:

1. **Verifique os logs da Vercel**:
   - Acesse o painel da Vercel
   - Vá para seu projeto > Deployments > Functions
   - Monitore os logs das funções `/api/cron/process-queue` e `/api/contracts/[id]/status`

2. **Monitore o Redis**:
   - Use o painel do Upstash para monitorar o tamanho da fila
   - Verifique se os itens estão sendo adicionados e removidos corretamente

3. **Teste de carga (opcional)**:
   - Use ferramentas como k6 ou Apache JMeter para simular múltiplos uploads simultâneos
   - Verifique se a fila processa todos os itens corretamente

## 5. Depuração

Se encontrar problemas:

1. **Verifique os logs do servidor** para erros específicos
2. **Inspecione a fila do Redis** usando o painel do Upstash
3. **Verifique o status dos contratos no banco de dados** para garantir que estão sendo atualizados corretamente

Lembre-se de remover os endpoints de teste antes de implantar em produção!

---

_**User**_

eu fiz o upload e ele nem chegou a chamra a fila, deu erro antes.

O erro que deu foi o "Analysis timeout. Please try again." no @UploadZone.tsx .

Por favor analise o que está ocorrendo e me traga uma solução completa para acabar de vez com o timeout usando a fila do upstash/redis

---

_**Assistant**_



# Solução para o problema de timeout no UploadZone.tsx

O erro "Analysis timeout. Please try again." está ocorrendo porque o componente `UploadZone.tsx` ainda está esperando a análise ser concluída de forma síncrona, em vez de usar o novo sistema de fila. Vamos modificar o componente para trabalhar com o processamento assíncrono.

## Modificação do UploadZone.tsx

```typescript:src/components/contracts/upload/UploadZone.tsx
// ... existing code ...

const handleUpload = async (file: File) => {
  try {
    setLoading(true);
    setShowProcessing(true);
    
    // Começar do 0 apenas se não houver progresso anterior
    if (progress === 0) {
      setProgress(0);
    }
    
    // Upload progress mais gradual (0-30%)
    let uploadProgress = 0;
    const uploadTimer = setInterval(() => {
      if (uploadProgress < 30) {
        uploadProgress += 0.5;
        setProgress(prev => Math.max(prev, uploadProgress));
      }
    }, 100);

    const formData = new FormData();
    formData.append('file', file);
    
    const data = await uploadContract(formData);
    clearInterval(uploadTimer);

    if (!data.success) {
      throw new Error(data.error || 'Invalid response from server');
    }

    // Novo fluxo: Se não estiver autenticado, redireciona para preview
    if (!session) {
      setProgress(100);
      toast.success('Contract analyzed! Register to see the results.');
      router.push(`/preview/${data.tempId}`);
      return;
    }

    // Garantir que estamos em pelo menos 35% antes de começar a análise
    setProgress(prev => Math.max(prev, 35));
    
    // Redirecionar para a página do contrato onde o status será monitorado
    toast.success('Contract uploaded! You will be redirected to view the analysis progress.');
    
    // Simular progresso até 80% enquanto redirecionamos
    let redirectProgress = 35;
    const redirectTimer = setInterval(() => {
      if (redirectProgress < 80) {
        redirectProgress += 1;
        setProgress(redirectProgress);
      }
    }, 100);
    
    // Pequeno delay antes do redirecionamento para mostrar o progresso
    await new Promise(resolve => setTimeout(resolve, 1500));
    clearInterval(redirectTimer);
    
    // Redirecionar para a página do contrato
    router.push(`/contracts/${data.contract.id}`);

  } catch (error) {
    console.error('Upload error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Upload failed';
    setError(errorMessage);
    toast.error(errorMessage);
    setShowProcessing(false);
    setLoading(false);
  }
};

// Remover a função waitForAnalysis, pois agora o monitoramento será feito na página do contrato
// ... rest of the component remains the same ...
```

## Modificação da API de upload para usar a fila

```typescript:src/app/api/contracts/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { PrismaClient } from '@prisma/client';
import { processContractInBackground } from '@/lib/process';

const prisma = new PrismaClient();

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    const userId = session?.user?.id;

    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    // Criar o contrato no banco de dados com status inicial
    const contract = await prisma.contract.create({
      data: {
        name: file.name,
        status: 'uploading',
        userId: userId || null,
        // Outros campos iniciais
      }
    });

    // Iniciar o processamento em background
    await processContractInBackground(contract.id, file, userId || '');

    return NextResponse.json({
      success: true,
      contract: {
        id: contract.id,
        name: contract.name,
        status: contract.status
      }
    });
  } catch (error) {
    console.error('Upload error:', error);
    return NextResponse.json(
      { success: false, error: error instanceof Error ? error.message : 'Upload failed' },
      { status: 500 }
    );
  }
}
```

## Criação de um componente de monitoramento para a página do contrato

```typescript:src/components/contracts/ContractProcessingMonitor.tsx
'use client';

import { useState, useEffect } from 'react';
import { Progress } from '@/components/ui/progress';
import { toast } from 'sonner';

interface ContractProcessingMonitorProps {
  contractId: string;
  initialStatus: string;
  onComplete?: () => void;
}

export function ContractProcessingMonitor({
  contractId,
  initialStatus,
  onComplete
}: ContractProcessingMonitorProps) {
  const [status, setStatus] = useState(initialStatus);
  const [progress, setProgress] = useState(initialStatus === 'under_review' ? 100 : 35);
  const [isComplete, setIsComplete] = useState(initialStatus === 'under_review');

  useEffect(() => {
    if (isComplete) return;

    // Simular progresso visual enquanto aguarda
    const progressInterval = setInterval(() => {
      setProgress(prev => {
        // Limitar o progresso máximo a 95% até que a análise seja concluída
        if (prev < 95) {
          return prev + 0.2;
        }
        return prev;
      });
    }, 300);

    // Verificar o status do contrato periodicamente
    const statusInterval = setInterval(async () => {
      try {
        const response = await fetch(`/api/contracts/${contractId}/status`);
        const data = await response.json();
        
        setStatus(data.status);
        
        if (data.status === 'under_review') {
          clearInterval(progressInterval);
          clearInterval(statusInterval);
          setProgress(100);
          setIsComplete(true);
          toast.success('Contract analysis complete!');
          if (onComplete) onComplete();
        } else if (data.status === 'error') {
          clearInterval(progressInterval);
          clearInterval(statusInterval);
          toast.error('Error analyzing contract. Please try again.');
        }
      } catch (error) {
        console.error('Error checking contract status:', error);
      }
    }, 5000); // Verificar a cada 5 segundos

    return () => {
      clearInterval(progressInterval);
      clearInterval(statusInterval);
    };
  }, [contractId, isComplete, onComplete]);

  if (isComplete) return null;

  return (
    <div className="w-full p-4 bg-blue-900/20 rounded-lg mb-6">
      <div className="mb-2 flex justify-between items-center">
        <h3 className="text-white font-medium">Analyzing your contract</h3>
        <span className="text-sm text-blue-300">{Math.round(progress)}%</span>
      </div>
      <Progress value={progress} className="h-2 mb-2" />
      <p className="text-sm text-blue-300">
        {status === 'uploading' && 'Uploading your contract...'}
        {status === 'processing' && 'Processing your contract...'}
        {status === 'analyzing' && 'AI is analyzing your contract...'}
        {status === 'error' && 'Error analyzing your contract. Please try again.'}
      </p>
    </div>
  );
}
```

## Atualização da página do contrato para usar o monitor

```typescript:src/app/(protected)/contracts/[id]/page.tsx
import { ContractProcessingMonitor } from '@/components/contracts/ContractProcessingMonitor';

// No seu componente de página:
export default async function ContractPage({ params }: { params: { id: string } }) {
  const contract = await getContract(params.id);
  
  // Verificar se o contrato está em processamento
  const isProcessing = ['uploading', 'processing', 'analyzing'].includes(contract.status);
  
  return (
    <div>
      {isProcessing && (
        <ContractProcessingMonitor 
          contractId={contract.id} 
          initialStatus={contract.status} 
          onComplete={() => {
            // Opcional: recarregar a página quando a análise for concluída
            window.location.reload();
          }}
        />
      )}
      
      {/* Resto do conteúdo da página */}
      {contract.status === 'under_review' ? (
        // Mostrar os resultados da análise
        <div>
          {/* Conteúdo da análise */}
        </div>
      ) : (
        // Mostrar mensagem de espera se ainda estiver processando
        !isProcessing && (
          <div className="text-center py-12">
            <p>Contract analysis failed. Please try uploading again.</p>
          </div>
        )
      )}
    </div>
  );
}
```

## Atualização da API de status do contrato

```typescript:src/app/api/contracts/[id]/status/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const contractId = params.id;
    
    const contract = await prisma.contract.findUnique({
      where: { id: contractId },
      select: { 
        status: true,
        issues: true,
        updatedAt: true
      }
    });
    
    if (!contract) {
      return NextResponse.json({ error: 'Contract not found' }, { status: 404 });
    }
    
    // Verificar se há issues para determinar se a análise está completa
    const hasIssues = Array.isArray(contract.issues) && contract.issues.length > 0;
    
    return NextResponse.json({ 
      status: contract.status,
      hasIssues,
      updatedAt: contract.updatedAt
    });
  } catch (error) {
    console.error('Error fetching contract status:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
```

## Atualização do processamento em segundo plano

```typescript:src/lib/process.ts
// ... existing code ...

export async function processContractInBackground(
  contractId: string, 
  file: File, 
  userId: string
) {
  try {
    // Atualizar status para uploading
    await prisma.contract.update({
      where: { id: contractId },
      data: { status: "uploading" }
    });

    // 1. Upload do arquivo para o Supabase
    const sanitizedFileName = sanitizeFileName(file.name);
    const uniqueFileName = `${Date.now()}-${sanitizedFileName}`;
    const buffer = await file.arrayBuffer();

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('contracts')
      .upload(uniqueFileName, buffer, {
        contentType: file.type,
        upsert: false
      });

    if (uploadError) throw uploadError;

    const { data: { publicUrl } } = supabase.storage
      .from('contracts')
      .getPublicUrl(uploadData.path);

    // 2. Extrair texto e coordenadas
    const { text, numPages, textCoordinates } = await extractTextContent(file);

    // 3. Atualizar status para processing
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        fileUrl: publicUrl,
        content: text,
        numPages: numPages,
        status: "processing" // Atualiza status para processing
      }
    });

    // 4. Adicionar à fila do Redis para processamento assíncrono
    await redis.lpush('contract-analysis-queue', JSON.stringify({
      contractId,
      userId,
      text,
      textCoordinates: Array.from(textCoordinates.entries())
    }));

    // Retorna imediatamente após colocar na fila
    return { success: true, status: "processing" };

  } catch (error) {
    console.error('Background processing error:', error);
    
    // Atualizar contrato com erro
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'error',
        metadata: {
          error: error instanceof Error ? error.message : 'Processing failed'
        }
      }
    });
    
    return { success: false, error: error instanceof Error ? error.message : 'Processing failed' };
  }
}

export async function processAnalysisQueue() {
  try {
    // Pega o próximo item da fila (sem remover)
    const queueItem = await redis.lindex('contract-analysis-queue', 0);
    
    if (!queueItem) {
      return { success: true, message: "No items in queue" };
    }
    
    const { contractId, userId, text, textCoordinates } = JSON.parse(queueItem);
    
    // Atualizar status para analyzing
    await prisma.contract.update({
      where: { id: contractId },
      data: { status: "analyzing" }
    });
    
    // Reconstruir o Map de coordenadas
    const coordsMap = new Map(textCoordinates);
    
    // Realizar a análise
    const analysisResult = await analyzeContract(text, coordsMap);
    
    // Atualizar o contrato com os resultados
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        issues: JSON.parse(JSON.stringify(analysisResult.issues)),
        suggestedClauses: JSON.parse(JSON.stringify(analysisResult.suggestedClauses)),
        status: "under_review",
        updatedAt: new Date()
      }
    });
    
    // Remover o item da fila após processamento bem-sucedido
    await redis.lpop('contract-analysis-queue');
    
    return { success: true, contractId };
    
  } catch (error) {
    console.error('Queue processing error:', error);
    
    // Tentar obter o contractId do item atual
    try {
      const queueItem = await redis.lindex('contract-analysis-queue', 0);
      if (queueItem) {
        const { contractId } = JSON.parse(queueItem);
        
        // Atualizar contrato com erro
        await prisma.contract.update({
          where: { id: contractId },
          data: {
            status: 'error',
            metadata: {
              error: error instanceof Error ? error.message : 'Analysis failed'
            }
          }
        });
        
        // Remover o item com erro da fila
        await redis.lpop('contract-analysis-queue');
      }
    } catch (innerError) {
      console.error('Error handling queue failure:', innerError);
    }
    
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Queue processing failed' 
    };
  }
}
```

## Como testar

1. **Inicie o servidor de desenvolvimento**:
   ```
   npm run dev
   ```

2. **Verifique se o Upstash Redis está configurado corretamente**:
   - Confirme que as variáveis de ambiente estão definidas
   - Teste a conexão com o Redis usando um endpoint de teste temporário

3. **Teste o fluxo completo**:
   - Faça upload de um contrato
   - Observe o redirecionamento para a página do contrato
   - Verifique se o monitor de progresso aparece
   - Acesse manualmente `/api/cron/process-queue` para processar a fila
   - Observe se o status é atualizado e o monitor mostra o progresso

Esta implementação completa resolve o problema de timeout ao:

1. Separar completamente o upload do processamento
2. Redirecionar imediatamente o usuário para a página do contrato
3. Mostrar um monitor de progresso em tempo real
4. Processar a análise de forma assíncrona via fila Redis
5. Atualizar a interface do usuário quando a análise for concluída

Agora o sistema deve funcionar sem timeouts, mesmo para contratos grandes ou análises demoradas.

---

_**User**_

eu fui testar e logo ao fazer o upload este erro apareceu

---

_**Assistant**_



# Resolvendo o erro de restrição de status no Prisma

O erro que você está enfrentando é um problema de validação no banco de dados PostgreSQL. A mensagem de erro indica que há uma restrição de verificação (`check constraint`) chamada `contract_status_check` que está sendo violada quando você tenta atualizar o status para "uploading" ou "error".

Este erro ocorre porque o modelo `Contract` no seu schema Prisma provavelmente tem uma enumeração para o campo `status` que não inclui os valores que estamos tentando usar.

Vamos resolver isso:

## 1. Atualize o schema Prisma

```prisma:prisma/schema.prisma
// Encontre a enum ContractStatus (ou similar) no seu schema
enum ContractStatus {
  DRAFT
  UNDER_REVIEW
  APPROVED
  REJECTED
  // Adicione os novos status que estamos usando
  UPLOADING
  PROCESSING
  ANALYZING
  ERROR
}

// Ou, se o status for uma string com validação, modifique o modelo Contract:
model Contract {
  // ... outros campos
  status String @default("DRAFT")
  // ... outros campos
}
```

Após modificar o schema, execute:

```bash
npx prisma generate
npx prisma db push
```

## 2. Ajuste o código para usar os valores corretos de status

```typescript:src/lib/process.ts
export async function processContractInBackground(
  contractId: string, 
  file: File, 
  userId: string
) {
  try {
    // Verifique quais valores de status são permitidos no seu banco de dados
    // Use valores em maiúsculas se o seu schema usar enum dessa forma
    await prisma.contract.update({
      where: { id: contractId },
      data: { status: "UPLOADING" } // Use maiúsculas se necessário
    });

    // ... resto do código ...

    await prisma.contract.update({
      where: { id: contractId },
      data: {
        fileUrl: publicUrl,
        content: text,
        numPages: numPages,
        status: "PROCESSING" // Use maiúsculas se necessário
      }
    });

    // ... resto do código ...
  } catch (error) {
    console.error('Background processing error:', error);
    
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'ERROR', // Use maiúsculas se necessário
        metadata: {
          error: error instanceof Error ? error.message : 'Processing failed'
        }
      }
    });
    
    return { success: false, error: error instanceof Error ? error.message : 'Processing failed' };
  }
}

export async function processAnalysisQueue() {
  try {
    // ... código existente ...
    
    await prisma.contract.update({
      where: { id: contractId },
      data: { status: "ANALYZING" } // Use maiúsculas se necessário
    });
    
    // ... código existente ...
    
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        issues: JSON.parse(JSON.stringify(analysisResult.issues)),
        suggestedClauses: JSON.parse(JSON.stringify(analysisResult.suggestedClauses)),
        status: "UNDER_REVIEW", // Use maiúsculas se necessário
        updatedAt: new Date()
      }
    });
    
    // ... resto do código ...
  } catch (error) {
    // ... código de tratamento de erro ...
    
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'ERROR', // Use maiúsculas se necessário
        metadata: {
          error: error instanceof Error ? error.message : 'Analysis failed'
        }
      }
    });
    
    // ... resto do código ...
  }
}
```

## 3. Atualize a API de upload para usar os valores corretos

```typescript:src/app/api/contracts/upload/route.ts
// ... código existente ...

const contract = await prisma.contract.create({
  data: {
    name: file.name,
    status: 'DRAFT', // Use o valor inicial correto conforme seu schema
    userId: userId || null,
    // Outros campos iniciais
  }
});

// ... resto do código ...
```

## 4. Atualize o componente de monitoramento para corresponder aos valores do banco de dados

```typescript:src/components/contracts/ContractProcessingMonitor.tsx
// ... código existente ...

// Verificar se o contrato está em processamento
const isProcessing = ['UPLOADING', 'PROCESSING', 'ANALYZING'].includes(contract.status);

// ... e mais abaixo no componente ...

<p className="text-sm text-blue-300">
  {status === 'UPLOADING' && 'Uploading your contract...'}
  {status === 'PROCESSING' && 'Processing your contract...'}
  {status === 'ANALYZING' && 'AI is analyzing your contract...'}
  {status === 'ERROR' && 'Error analyzing your contract. Please try again.'}
</p>
```

## 5. Verifique o modelo Contract no código

Se você tiver um tipo ou interface `Contract` definido em seu código TypeScript, certifique-se de que ele também inclua os novos valores de status:

```typescript:src/types/index.ts
// Exemplo - ajuste conforme seu código
export type ContractStatus = 
  | 'DRAFT' 
  | 'UNDER_REVIEW' 
  | 'APPROVED' 
  | 'REJECTED'
  | 'UPLOADING'
  | 'PROCESSING'
  | 'ANALYZING'
  | 'ERROR';

export interface Contract {
  id: string;
  name: string;
  status: ContractStatus;
  // ... outros campos
}
```

Esta solução deve resolver o erro de restrição de verificação no banco de dados, permitindo que você use os novos valores de status para o processamento assíncrono.

---

_**User**_

no passo 1 da sua atualização no prisma, por favor me ajude a usar a estrutura enum contract_status já existente para que eu não precise migrar o banco de dados

---

_**Assistant**_



Entendi! Vamos usar a enum `contract_status` já existente no seu schema Prisma em vez de criar uma nova. Isso evitará a necessidade de migração do banco de dados.

## 1. Atualização do schema Prisma para usar a enum existente

```prisma:prisma/schema.prisma
// ... existing code ...

model Contract {
  id         String   @id @default(uuid()) @db.Uuid
  title      String
  content    String
  status     contract_status  // Usar a enum existente
  fileUrl    String
  fileName   String
  fileType   String
  userId     String   @db.Uuid
  numPages     Int      @default(1)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  highlights Json @default("[]")
  changes Json @default("[]")
  issues Json @default("[]") @db.JsonB    // Alterado de highlights
  suggestedClauses Json @default("[]") @db.JsonB    // Alterado de changes
  pdfPositions Json? @db.JsonB
  metadata Json @default("{\"pageCount\": 1}") @db.JsonB // Novo campo
  user       User     @relation(fields: [userId], references: [id])

  @@index([userId])
}

// ... existing code ...

enum contract_status {
  draft
  under_review
  approved
  rejected
  uploading  // Adicionar novos status
  processing
  analyzing
  error
}
```

Após modificar o schema, execute apenas:

```bash
npx prisma generate
```

Isso atualizará o cliente Prisma sem alterar o banco de dados.

## 2. Ajuste o código para usar os valores corretos de status

```typescript:src/lib/process.ts
export async function processContractInBackground(
  contractId: string, 
  file: File, 
  userId: string
) {
  try {
    // Usar os valores da enum existente (em minúsculas)
    await prisma.contract.update({
      where: { id: contractId },
      data: { status: "uploading" }
    });

    // ... resto do código ...

    await prisma.contract.update({
      where: { id: contractId },
      data: {
        fileUrl: publicUrl,
        content: text,
        numPages: numPages,
        status: "processing"
      }
    });

    // ... resto do código ...
  } catch (error) {
    console.error('Background processing error:', error);
    
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'error',
        metadata: {
          error: error instanceof Error ? error.message : 'Processing failed'
        }
      }
    });
    
    return { success: false, error: error instanceof Error ? error.message : 'Processing failed' };
  }
}

export async function processAnalysisQueue() {
  try {
    // ... código existente ...
    
    await prisma.contract.update({
      where: { id: contractId },
      data: { status: "analyzing" }
    });
    
    // ... código existente ...
    
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        issues: JSON.parse(JSON.stringify(analysisResult.issues)),
        suggestedClauses: JSON.parse(JSON.stringify(analysisResult.suggestedClauses)),
        status: "under_review",
        updatedAt: new Date()
      }
    });
    
    // ... resto do código ...
  } catch (error) {
    // ... código de tratamento de erro ...
    
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'error',
        metadata: {
          error: error instanceof Error ? error.message : 'Analysis failed'
        }
      }
    });
    
    // ... resto do código ...
  }
}
```

## 3. Atualize a API de upload para usar os valores corretos

```typescript:src/app/api/contracts/upload/route.ts
// ... código existente ...

const contract = await prisma.contract.create({
  data: {
    title: file.name,
    fileName: file.name,
    fileType: file.type,
    content: "",
    status: 'draft', // Usar o valor da enum existente
    userId: userId,
    // Outros campos necessários
  }
});

// ... resto do código ...
```

## 4. Atualize o componente de monitoramento para corresponder aos valores do banco de dados

```typescript:src/components/contracts/ContractProcessingMonitor.tsx
'use client';

import { useState, useEffect } from 'react';
import { Progress } from '@/components/ui/progress';
import { toast } from 'sonner';

interface ContractProcessingMonitorProps {
  contractId: string;
  initialStatus: string;
  onComplete?: () => void;
}

export function ContractProcessingMonitor({
  contractId,
  initialStatus,
  onComplete
}: ContractProcessingMonitorProps) {
  const [status, setStatus] = useState(initialStatus);
  const [progress, setProgress] = useState(initialStatus === 'under_review' ? 100 : 35);
  const [isComplete, setIsComplete] = useState(initialStatus === 'under_review');

  useEffect(() => {
    if (isComplete) return;

    // Simular progresso visual enquanto aguarda
    const progressInterval = setInterval(() => {
      setProgress(prev => {
        // Limitar o progresso máximo a 95% até que a análise seja concluída
        if (prev < 95) {
          return prev + 0.2;
        }
        return prev;
      });
    }, 300);

    // Verificar o status do contrato periodicamente
    const statusInterval = setInterval(async () => {
      try {
        const response = await fetch(`/api/contracts/${contractId}/status`);
        const data = await response.json();
        
        setStatus(data.status);
        
        if (data.status === 'under_review') {
          clearInterval(progressInterval);
          clearInterval(statusInterval);
          setProgress(100);
          setIsComplete(true);
          toast.success('Contract analysis complete!');
          if (onComplete) onComplete();
        } else if (data.status === 'error') {
          clearInterval(progressInterval);
          clearInterval(statusInterval);
          toast.error('Error analyzing contract. Please try again.');
        }
      } catch (error) {
        console.error('Error checking contract status:', error);
      }
    }, 5000); // Verificar a cada 5 segundos

    return () => {
      clearInterval(progressInterval);
      clearInterval(statusInterval);
    };
  }, [contractId, isComplete, onComplete]);

  if (isComplete) return null;

  return (
    <div className="w-full p-4 bg-blue-900/20 rounded-lg mb-6">
      <div className="mb-2 flex justify-between items-center">
        <h3 className="text-white font-medium">Analyzing your contract</h3>
        <span className="text-sm text-blue-300">{Math.round(progress)}%</span>
      </div>
      <Progress value={progress} className="h-2 mb-2" />
      <p className="text-sm text-blue-300">
        {status === 'uploading' && 'Uploading your contract...'}
        {status === 'processing' && 'Processing your contract...'}
        {status === 'analyzing' && 'AI is analyzing your contract...'}
        {status === 'error' && 'Error analyzing your contract. Please try again.'}
      </p>
    </div>
  );
}
```

Esta abordagem usa a enum `contract_status` existente, adicionando apenas os novos valores necessários. Isso evita a necessidade de migração do banco de dados, pois estamos apenas estendendo uma enum existente.

Após fazer essas alterações, execute `npx prisma generate` para atualizar o cliente Prisma com os novos valores da enum, e você estará pronto para usar o sistema de fila com os status corretos.

---

_**User**_

este erro ainda ocorre quando eu começo a testar "Invalid `prisma.contract.create()` invocation: Error occurred during query execution: ConnectorError(ConnectorError { user_facing_error: None, kind: QueryError(PostgresError { code: "23514", message: "new row for relation \"Contract\" violates check constraint \"contract_status_check\"", severity: "ERROR", detail: Some("Failing row contains (d0cca64f-b610-4371-bc5d-5c501cdeb2a4, contrato.de_.locacao.006-7a4 - co\u{301}pia.pdf, , DRAFT, , contrato.de_.locacao.006-7a4 - co\u{301}pia.pdf, application/pdf, 1118da77-5ce1-43f6-b52e-03a11d5bd956, 2025-03-03 19:19:51.095, 2025-03-03 19:19:51.095, [], [], null, 0, [], [], {\"createdAt\": \"2025-03-03T19:19:49.916Z\", \"updatedAt\": \"2025-03-...)."), column: None, hint: None }), transient: false })"

---

_**Assistant**_



# Resolvendo o erro de restrição de status no Prisma

O erro persiste porque estamos tentando usar um valor de status (`DRAFT`) que não está na lista de valores permitidos pela restrição `contract_status_check` no banco de dados.

Vamos verificar quais são os valores permitidos pela enum no banco de dados e usar exatamente esses valores.

## 1. Verificar os valores permitidos no banco de dados

Para descobrir quais valores são permitidos pela enum `contract_status` no seu banco de dados PostgreSQL, você pode executar a seguinte consulta SQL:

```sql
SELECT enum_range(NULL::contract_status);
```

Isso mostrará todos os valores permitidos pela enum.

## 2. Atualizar o código para usar os valores corretos

Vamos ajustar o código para usar os valores exatos que são permitidos no banco de dados:

```typescript:src/app/api/contracts/upload/route.ts
// ... código existente ...

const contract = await prisma.contract.create({
  data: {
    title: file.name,
    fileName: file.name,
    fileType: file.type,
    content: "",
    status: 'draft', // Usar o valor exato da enum no banco de dados (minúsculas)
    userId: userId,
    // Outros campos necessários
    numPages: 0, // Valor inicial
    issues: [],
    suggestedClauses: [],
    metadata: {}
  }
});

// ... resto do código ...
```

## 3. Verificar o modelo Contract no Prisma

Vamos verificar como o modelo `Contract` está definido no seu schema Prisma:

```typescript:src/lib/db.ts
// Adicione este código temporário para depuração
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Função para verificar os valores da enum
async function checkEnumValues() {
  try {
    // Consulta direta ao banco de dados
    const result = await prisma.$queryRaw`SELECT enum_range(NULL::contract_status)`;
    console.log('Valores permitidos para contract_status:', result);
    
    // Verificar a definição do modelo Contract
    console.log('Modelo Contract:', prisma.contract);
  } catch (error) {
    console.error('Erro ao verificar enum:', error);
  }
}

checkEnumValues();
```

Execute este código temporariamente para ver quais são os valores permitidos.

## 4. Solução alternativa: usar valores brutos

Se você continuar enfrentando problemas, podemos usar uma abordagem mais direta com valores brutos:

```typescript:src/app/api/contracts/upload/route.ts
// ... código existente ...

// Usar Prisma.$queryRaw para inserir diretamente com o valor correto
const contract = await prisma.$queryRaw`
  INSERT INTO "Contract" (
    "id", "title", "content", "status", "fileUrl", "fileName", "fileType", 
    "userId", "numPages", "createdAt", "updatedAt", "issues", "suggestedClauses", "metadata"
  ) 
  VALUES (
    ${crypto.randomUUID()}, ${file.name}, '', 'draft', '', ${file.name}, 
    ${file.type}, ${userId}, 0, NOW(), NOW(), '[]', '[]', '{}'
  )
  RETURNING "id", "title", "status"
`;

// ... resto do código ...
```

## 5. Verificar o schema do banco de dados

Se possível, verifique diretamente o schema do banco de dados para ver a definição exata da restrição `contract_status_check`:

```sql
SELECT conname, pg_get_constraintdef(oid) 
FROM pg_constraint 
WHERE conname = 'contract_status_check';
```

Isso mostrará a definição exata da restrição, o que pode ajudar a entender quais valores são permitidos.

## 6. Solução temporária: modificar a restrição

Se você tiver acesso direto ao banco de dados, pode modificar temporariamente a restrição para aceitar os novos valores:

```sql
ALTER TYPE contract_status ADD VALUE 'draft' AFTER 'rejected';
ALTER TYPE contract_status ADD VALUE 'uploading' AFTER 'draft';
ALTER TYPE contract_status ADD VALUE 'processing' AFTER 'uploading';
ALTER TYPE contract_status ADD VALUE 'analyzing' AFTER 'processing';
ALTER TYPE contract_status ADD VALUE 'error' AFTER 'analyzing';
```

## 7. Solução para desenvolvimento: usar um valor existente temporariamente

Para fins de desenvolvimento, você pode usar temporariamente um valor que já existe na enum:

```typescript:src/app/api/contracts/upload/route.ts
const contract = await prisma.contract.create({
  data: {
    title: file.name,
    fileName: file.name,
    fileType: file.type,
    content: "",
    // Use um valor que você sabe que existe na enum
    status: 'under_review', // ou qualquer outro valor que você sabe que funciona
    userId: userId,
    // Outros campos necessários
  }
});
```

Depois, você pode atualizar o status para o valor desejado após descobrir quais são os valores permitidos.

Estas abordagens devem ajudar a resolver o problema de restrição de verificação no banco de dados.

---

_**User**_

este foi o retorno do SQL.

{draft,under_review,approved,rejected}

Lembrando que no meu prisma está assim: 


---

_**Assistant**_



# Resolvendo a discrepância entre o schema Prisma e o banco de dados

Agora entendo o problema! Há uma discrepância entre o schema Prisma e o banco de dados:

1. No seu schema Prisma, a enum `contract_status` tem valores em MAIÚSCULAS e inclui os novos status
2. No banco de dados, a enum tem valores em minúsculas e não inclui os novos status

Vamos resolver isso:

## 1. Atualize o schema Prisma para corresponder ao banco de dados

```prisma:prisma/schema.prisma
enum contract_status {
  draft
  under_review
  approved
  rejected
  // Os novos valores serão adicionados via migração
}
```

## 2. Crie uma migração para adicionar os novos valores à enum

```sql:prisma/migrations/add_new_status_values/migration.sql
-- AlterEnum
ALTER TYPE "contract_status" ADD VALUE 'uploading';
ALTER TYPE "contract_status" ADD VALUE 'processing';
ALTER TYPE "contract_status" ADD VALUE 'analyzing';
ALTER TYPE "contract_status" ADD VALUE 'error';
```

Execute a migração:
```bash
npx prisma migrate dev --name add_new_status_values
```

## 3. Atualize o código para usar os valores corretos (em minúsculas)

```typescript:src/lib/process.ts
export async function processContractInBackground(
  contractId: string, 
  file: File, 
  userId: string
) {
  try {
    // Usar os valores em minúsculas conforme o banco de dados
    await prisma.contract.update({
      where: { id: contractId },
      data: { status: "uploading" }
    });

    // ... resto do código ...

    await prisma.contract.update({
      where: { id: contractId },
      data: {
        fileUrl: publicUrl,
        content: text,
        numPages: numPages,
        status: "processing"
      }
    });

    // ... resto do código ...
  } catch (error) {
    console.error('Background processing error:', error);
    
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'error',
        metadata: {
          error: error instanceof Error ? error.message : 'Processing failed'
        }
      }
    });
    
    return { success: false, error: error instanceof Error ? error.message : 'Processing failed' };
  }
}

export async function processAnalysisQueue() {
  try {
    // ... código existente ...
    
    await prisma.contract.update({
      where: { id: contractId },
      data: { status: "analyzing" }
    });
    
    // ... código existente ...
    
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        issues: JSON.parse(JSON.stringify(analysisResult.issues)),
        suggestedClauses: JSON.parse(JSON.stringify(analysisResult.suggestedClauses)),
        status: "under_review",
        updatedAt: new Date()
      }
    });
    
    // ... resto do código ...
  } catch (error) {
    // ... código de tratamento de erro ...
    
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'error',
        metadata: {
          error: error instanceof Error ? error.message : 'Analysis failed'
        }
      }
    });
    
    // ... resto do código ...
  }
}
```

## 4. Atualize a API de upload para usar os valores corretos

```typescript:src/app/api/contracts/upload/route.ts
// ... código existente ...

const contract = await prisma.contract.create({
  data: {
    title: file.name,
    fileName: file.name,
    fileType: file.type,
    content: "",
    status: 'draft', // Usar o valor em minúsculas
    userId: userId,
    // Outros campos necessários
  }
});

// ... resto do código ...
```

## 5. Solução temporária (se não quiser fazer migração)

Se você não quiser fazer uma migração agora, pode usar apenas os valores existentes no banco de dados:

```typescript:src/lib/process.ts
// Use 'draft' para iniciar
// Use 'under_review' quando estiver processando
// Use 'approved' quando concluir com sucesso
// Use 'rejected' quando houver erro

export async function processContractInBackground(
  contractId: string, 
  file: File, 
  userId: string
) {
  try {
    // Usar valores existentes
    await prisma.contract.update({
      where: { id: contractId },
      data: { status: "draft" } // Inicialmente como draft
    });

    // ... resto do código ...

    await prisma.contract.update({
      where: { id: contractId },
      data: {
        fileUrl: publicUrl,
        content: text,
        numPages: numPages,
        status: "under_review" // Em processamento como under_review
      }
    });

    // ... resto do código ...
  } catch (error) {
    console.error('Background processing error:', error);
    
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'rejected', // Erro como rejected
        metadata: {
          error: error instanceof Error ? error.message : 'Processing failed'
        }
      }
    });
    
    return { success: false, error: error instanceof Error ? error.message : 'Processing failed' };
  }
}
```

Esta solução resolve a discrepância entre o schema Prisma e o banco de dados, permitindo que você use os valores corretos de status para o processamento assíncrono.

---

_**User**_

eu não quero migrar, nao podemos fazer um SQL para que fique todas maiuscula igual no codigo?

"enum contract_status {
  DRAFT
  UNDER_REVIEW
  APPROVED
  REJECTED
  UPLOADING
  PROCESSING
  ANALYZING
  ERROR
}"

---

_**Assistant**_



# Atualizando a enum no banco de dados para usar valores em maiúsculas

Sim, podemos usar SQL para modificar a enum no banco de dados para que corresponda ao seu schema Prisma com valores em maiúsculas. Isso evitará a necessidade de alterar seu código.

## Passo a passo para atualizar a enum no banco de dados

### 1. Crie um tipo enum temporário com os novos valores

```sql
-- Criar um novo tipo enum com os valores em maiúsculas
CREATE TYPE contract_status_new AS ENUM (
  'DRAFT', 
  'UNDER_REVIEW', 
  'APPROVED', 
  'REJECTED',
  'UPLOADING',
  'PROCESSING',
  'ANALYZING',
  'ERROR'
);
```

### 2. Atualize a tabela para usar o novo tipo

```sql
-- Alterar a tabela para usar o novo tipo
ALTER TABLE "Contract" 
  ALTER COLUMN status TYPE contract_status_new 
  USING (
    CASE 
      WHEN status::text = 'draft' THEN 'DRAFT'::contract_status_new
      WHEN status::text = 'under_review' THEN 'UNDER_REVIEW'::contract_status_new
      WHEN status::text = 'approved' THEN 'APPROVED'::contract_status_new
      WHEN status::text = 'rejected' THEN 'REJECTED'::contract_status_new
      ELSE 'DRAFT'::contract_status_new
    END
  );
```

### 3. Remova o tipo antigo e renomeie o novo

```sql
-- Remover o tipo antigo e renomear o novo
DROP TYPE contract_status;
ALTER TYPE contract_status_new RENAME TO contract_status;
```

### 4. Execute o SQL no seu banco de dados

Você pode executar este SQL diretamente no seu banco de dados usando uma ferramenta como pgAdmin, DBeaver, ou o cliente psql.

Alternativamente, você pode usar o Prisma para executar SQL bruto:

```typescript
// script-update-enum.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function updateEnum() {
  try {
    // Criar novo tipo enum
    await prisma.$executeRawUnsafe(`
      CREATE TYPE contract_status_new AS ENUM (
        'DRAFT', 
        'UNDER_REVIEW', 
        'APPROVED', 
        'REJECTED',
        'UPLOADING',
        'PROCESSING',
        'ANALYZING',
        'ERROR'
      );
    `);

    // Atualizar a tabela
    await prisma.$executeRawUnsafe(`
      ALTER TABLE "Contract" 
        ALTER COLUMN status TYPE contract_status_new 
        USING (
          CASE 
            WHEN status::text = 'draft' THEN 'DRAFT'::contract_status_new
            WHEN status::text = 'under_review' THEN 'UNDER_REVIEW'::contract_status_new
            WHEN status::text = 'approved' THEN 'APPROVED'::contract_status_new
            WHEN status::text = 'rejected' THEN 'REJECTED'::contract_status_new
            ELSE 'DRAFT'::contract_status_new
          END
        );
    `);

    // Remover tipo antigo e renomear o novo
    await prisma.$executeRawUnsafe(`
      DROP TYPE contract_status;
      ALTER TYPE contract_status_new RENAME TO contract_status;
    `);

    console.log('Enum atualizada com sucesso!');
  } catch (error) {
    console.error('Erro ao atualizar enum:', error);
  } finally {
    await prisma.$disconnect();
  }
}

updateEnum();
```

Execute este script com:

```bash
npx ts-node script-update-enum.ts
```

### 5. Regenere o cliente Prisma

Após atualizar o banco de dados, regenere o cliente Prisma:

```bash
npx prisma generate
```

Agora seu banco de dados terá a enum `contract_status` com valores em maiúsculas, correspondendo exatamente ao seu schema Prisma, e você poderá usar os valores como `DRAFT`, `UPLOADING`, etc. no seu código sem problemas.

Esta abordagem evita a necessidade de migração formal do Prisma e permite que você mantenha seu código existente sem alterações.

---

_**User**_

deu erro no passo 2 do SQL

ERROR:  42883: operator does not exist: contract_status_new = text
HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.

---

_**Assistant**_





# Corrigindo o SQL para atualizar a enum no banco de dados

O erro ocorre porque estamos tentando comparar tipos incompatíveis. Vamos corrigir o SQL para fazer a conversão corretamente:

## SQL corrigido para atualizar a enum

### 1. Crie um tipo enum temporário com os novos valores

```sql
-- Criar um novo tipo enum com os valores em maiúsculas
CREATE TYPE contract_status_new AS ENUM (
  'DRAFT', 
  'UNDER_REVIEW', 
  'APPROVED', 
  'REJECTED',
  'UPLOADING',
  'PROCESSING',
  'ANALYZING',
  'ERROR'
);
```


### 2. Atualize a tabela para usar o novo tipo (versão corrigida)

```sql
-- Alterar a tabela para usar o novo tipo
ALTER TABLE "Contract" 
  ALTER COLUMN status TYPE contract_status_new 
  USING (
    CASE 
      WHEN status = 'draft' THEN 'DRAFT'::contract_status_new
      WHEN status = 'under_review' THEN 'UNDER_REVIEW'::contract_status_new
      WHEN status = 'approved' THEN 'APPROVED'::contract_status_new
      WHEN status = 'rejected' THEN 'REJECTED'::contract_status_new
      ELSE 'DRAFT'::contract_status_new
    END
  );
```


### 3. Remova o tipo antigo e renomeie o novo

```sql
-- Remover o tipo antigo e renomear o novo
DROP TYPE contract_status;
ALTER TYPE contract_status_new RENAME TO contract_status;
```


## Abordagem alternativa (mais segura)

Se o método acima ainda apresentar problemas, podemos usar uma abordagem mais segura com uma coluna temporária:

```sql
-- 1. Adicionar uma coluna temporária com o novo tipo
ALTER TABLE "Contract" ADD COLUMN status_new contract_status_new;

-- 2. Atualizar a coluna temporária com os valores convertidos
UPDATE "Contract" SET status_new = 
  CASE 
    WHEN status::text = 'draft' THEN 'DRAFT'::contract_status_new
    WHEN status::text = 'under_review' THEN 'UNDER_REVIEW'::contract_status_new
    WHEN status::text = 'approved' THEN 'APPROVED'::contract_status_new
    WHEN status::text = 'rejected' THEN 'REJECTED'::contract_status_new
    ELSE 'DRAFT'::contract_status_new
  END;

-- 3. Remover a coluna antiga
ALTER TABLE "Contract" DROP COLUMN status;

-- 4. Renomear a coluna temporária
ALTER TABLE "Contract" RENAME COLUMN status_new TO status;

-- 5. Remover o tipo antigo
DROP TYPE contract_status;

-- 6. Renomear o novo tipo
ALTER TYPE contract_status_new RENAME TO contract_status;
```


## Script TypeScript corrigido

```typescript
// script-update-enum.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function updateEnum() {
  try {
    // Criar novo tipo enum
    await prisma.$executeRawUnsafe(`
      CREATE TYPE contract_status_new AS ENUM (
        'DRAFT', 
        'UNDER_REVIEW', 
        'APPROVED', 
        'REJECTED',
        'UPLOADING',
        'PROCESSING',
        'ANALYZING',
        'ERROR'
      );
    `);

    // Usar abordagem com coluna temporária
    await prisma.$executeRawUnsafe(`
      -- Adicionar coluna temporária
      ALTER TABLE "Contract" ADD COLUMN status_new contract_status_new;
      
      -- Atualizar valores
      UPDATE "Contract" SET status_new = 
        CASE 
          WHEN status::text = 'draft' THEN 'DRAFT'::contract_status_new
          WHEN status::text = 'under_review' THEN 'UNDER_REVIEW'::contract_status_new
          WHEN status::text = 'approved' THEN 'APPROVED'::contract_status_new
          WHEN status::text = 'rejected' THEN 'REJECTED'::contract_status_new
          ELSE 'DRAFT'::contract_status_new
        END;
      
      -- Remover coluna antiga
      ALTER TABLE "Contract" DROP COLUMN status;
      
      -- Renomear coluna temporária
      ALTER TABLE "Contract" RENAME COLUMN status_new TO status;
    `);

    // Remover tipo antigo e renomear o novo
    await prisma.$executeRawUnsafe(`
      DROP TYPE contract_status;
      ALTER TYPE contract_status_new RENAME TO contract_status;
    `);

    console.log('Enum atualizada com sucesso!');
  } catch (error) {
    console.error('Erro ao atualizar enum:', error);
  } finally {
    await prisma.$disconnect();
  }
}

updateEnum();
```


Esta abordagem corrigida deve resolver o problema de incompatibilidade de tipos ao atualizar a enum no banco de dados.

---

_**User**_

ainda com erro, mesmo apos atualizar o contract_status

---

_**Assistant**_





# Solução para o erro de restrição de status

Vamos resolver este problema de uma vez por todas. O erro persiste porque ainda estamos tentando usar valores que não são aceitos pela restrição `contract_status_check`.

## Solução 1: Verificar os valores exatos aceitos pelo banco de dados

Vamos criar um endpoint temporário para verificar os valores exatos aceitos pelo banco de dados:

```typescript:src/app/api/debug/check-enum/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function GET() {
  try {
    // Consultar os valores aceitos pela enum
    const result = await prisma.$queryRaw`
      SELECT enum_range(NULL::contract_status);
    `;
    
    // Consultar a definição da restrição
    const constraint = await prisma.$queryRaw`
      SELECT pg_get_constraintdef(oid) 
      FROM pg_constraint 
      WHERE conname = 'contract_status_check';
    `;
    
    return NextResponse.json({ 
      enumValues: result,
      constraint
    });
  } catch (error) {
    console.error('Debug error:', error);
    return NextResponse.json({ error: String(error) }, { status: 500 });
  }
}
```


Acesse este endpoint para ver os valores exatos aceitos pelo banco de dados.

## Solução 2: Modificar o código para usar valores aceitos

Vamos modificar o código para usar apenas valores que sabemos que são aceitos pelo banco de dados:

```typescript:src/app/api/contracts/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { PrismaClient } from '@prisma/client';
import { processContractInBackground } from '@/lib/process';

const prisma = new PrismaClient();

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    const userId = session?.user?.id;

    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    // Usar um valor que sabemos que é aceito pelo banco de dados
    // Vamos usar 'draft' (ou o valor exato que você verificou no endpoint de debug)
    const contract = await prisma.contract.create({
      data: {
        title: file.name,
        fileName: file.name,
        fileType: file.type,
        content: "",
        status: 'draft', // Usar o valor exato aceito pelo banco de dados
        userId: userId,
        numPages: 0,
        issues: [],
        suggestedClauses: [],
        metadata: {}
      }
    });

    // Iniciar o processamento em background
    await processContractInBackground(contract.id, file, userId || '');

    return NextResponse.json({
      success: true,
      contract: {
        id: contract.id,
        name: contract.name || contract.title,
        status: contract.status
      }
    });
  } catch (error) {
    console.error('Upload error:', error);
    return NextResponse.json(
      { success: false, error: error instanceof Error ? error.message : 'Upload failed' },
      { status: 500 }
    );
  }
}
```


## Solução 3: Usar SQL bruto para inserir o contrato

Se o problema persistir, podemos usar SQL bruto para inserir o contrato:

```typescript:src/app/api/contracts/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { PrismaClient } from '@prisma/client';
import { processContractInBackground } from '@/lib/process';
import { randomUUID } from 'crypto';

const prisma = new PrismaClient();

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    const userId = session?.user?.id;

    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    // Gerar um ID para o contrato
    const contractId = randomUUID();
    
    // Inserir o contrato usando SQL bruto
    await prisma.$executeRaw`
      INSERT INTO "Contract" (
        "id", "title", "content", "status", "fileUrl", "fileName", "fileType", 
        "userId", "numPages", "createdAt", "updatedAt", "issues", "suggestedClauses", "metadata"
      ) 
      VALUES (
        ${contractId}::uuid, ${file.name}, '', 'draft', '', ${file.name}, 
        ${file.type}, ${userId}::uuid, 0, NOW(), NOW(), '[]'::jsonb, '[]'::jsonb, '{}'::jsonb
      )
    `;
    
    // Buscar o contrato criado
    const contract = await prisma.contract.findUnique({
      where: { id: contractId }
    });

    if (!contract) {
      throw new Error('Failed to create contract');
    }

    // Iniciar o processamento em background
    await processContractInBackground(contractId, file, userId || '');

    return NextResponse.json({
      success: true,
      contract: {
        id: contract.id,
        name: contract.title,
        status: contract.status
      }
    });
  } catch (error) {
    console.error('Upload error:', error);
    return NextResponse.json(
      { success: false, error: error instanceof Error ? error.message : 'Upload failed' },
      { status: 500 }
    );
  }
}
```


## Solução 4: Verificar e atualizar o schema Prisma

Se você ainda estiver enfrentando problemas, pode ser necessário verificar e atualizar o schema Prisma para garantir que ele corresponda exatamente ao banco de dados:

```prisma:prisma/schema.prisma
// Certifique-se de que a enum corresponda exatamente aos valores no banco de dados
enum contract_status {
  draft
  under_review
  approved
  rejected
}

model Contract {
  // ... outros campos
  status contract_status @default(draft)
  // ... outros campos
}
```


Após atualizar o schema, execute:

```bash
npx prisma generate
```


## Solução 5: Solução temporária para desenvolvimento

Para fins de desenvolvimento, você pode temporariamente modificar o código para usar valores fixos que você sabe que funcionam:

```typescript:src/lib/process.ts
export async function processContractInBackground(
  contractId: string, 
  file: File, 
  userId: string
) {
  try {
    // Usar valores que sabemos que funcionam
    // Não atualizar o status aqui para evitar o erro
    
    // 1. Upload do arquivo para o Supabase
    const sanitizedFileName = sanitizeFileName(file.name);
    const uniqueFileName = `${Date.now()}-${sanitizedFileName}`;
    const buffer = await file.arrayBuffer();

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('contracts')
      .upload(uniqueFileName, buffer, {
        contentType: file.type,
        upsert: false
      });

    if (uploadError) throw uploadError;

    const { data: { publicUrl } } = supabase.storage
      .from('contracts')
      .getPublicUrl(uploadData.path);

    // 2. Extrair texto e coordenadas
    const { text, numPages, textCoordinates } = await extractTextContent(file);

    // 3. Atualizar contrato sem mudar o status
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        fileUrl: publicUrl,
        content: text,
        numPages: numPages,
        // Não atualizar o status aqui
      }
    });

    // 4. Adicionar à fila do Redis para processamento assíncrono
    await redis.lpush('contract-analysis-queue', JSON.stringify({
      contractId,
      userId,
      text,
      textCoordinates: Array.from(textCoordinates.entries())
    }));

    return { success: true };
  } catch (error) {
    console.error('Background processing error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Processing failed' };
  }
}
```


Esta abordagem evita atualizar o status do contrato, o que pode contornar o problema temporariamente enquanto você resolve a questão da enum no banco de dados.

---

_**User**_

chat eu atualizei direto no SQL para aceitar todos os valores:
 desta forma "enum contract_status {
  DRAFT
  UNDER_REVIEW
  APPROVED
  REJECTED
  UPLOADING
  PROCESSING
  ANALYZING
  ERROR
  draft
  under_review
  approved
  rejected
}"

---

_**Assistant**_





# Ajustando o código para usar os valores corretos da enum

Excelente! Agora que você atualizou a enum `contract_status` no banco de dados para aceitar tanto valores em maiúsculas quanto em minúsculas, vamos ajustar o código para usar os valores em maiúsculas conforme seu schema Prisma original.

## 1. Atualizando o código de upload

```typescript:src/app/api/contracts/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { PrismaClient } from '@prisma/client';
import { processContractInBackground } from '@/lib/process';

const prisma = new PrismaClient();

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    const userId = session?.user?.id;

    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    // Criar o contrato com status DRAFT (em maiúsculas)
    const contract = await prisma.contract.create({
      data: {
        title: file.name,
        fileName: file.name,
        fileType: file.type,
        content: "",
        status: 'DRAFT', // Usar o valor em maiúsculas
        userId: userId,
        numPages: 0,
        issues: [],
        suggestedClauses: [],
        metadata: {}
      }
    });

    // Iniciar o processamento em background
    await processContractInBackground(contract.id, file, userId || '');

    return NextResponse.json({
      success: true,
      contract: {
        id: contract.id,
        name: contract.title,
        status: contract.status
      }
    });
  } catch (error) {
    console.error('Upload error:', error);
    return NextResponse.json(
      { success: false, error: error instanceof Error ? error.message : 'Upload failed' },
      { status: 500 }
    );
  }
}
```


## 2. Atualizando o processamento em background

```typescript:src/lib/process.ts
export async function processContractInBackground(
  contractId: string, 
  file: File, 
  userId: string
) {
  try {
    // Atualizar status para UPLOADING (em maiúsculas)
    await prisma.contract.update({
      where: { id: contractId },
      data: { status: "UPLOADING" }
    });

    // 1. Upload do arquivo para o Supabase
    const sanitizedFileName = sanitizeFileName(file.name);
    const uniqueFileName = `${Date.now()}-${sanitizedFileName}`;
    const buffer = await file.arrayBuffer();

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('contracts')
      .upload(uniqueFileName, buffer, {
        contentType: file.type,
        upsert: false
      });

    if (uploadError) throw uploadError;

    const { data: { publicUrl } } = supabase.storage
      .from('contracts')
      .getPublicUrl(uploadData.path);

    // 2. Extrair texto e coordenadas
    const { text, numPages, textCoordinates } = await extractTextContent(file);

    // 3. Atualizar status para PROCESSING (em maiúsculas)
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        fileUrl: publicUrl,
        content: text,
        numPages: numPages,
        status: "PROCESSING"
      }
    });

    // 4. Adicionar à fila do Redis para processamento assíncrono
    await redis.lpush('contract-analysis-queue', JSON.stringify({
      contractId,
      userId,
      text,
      textCoordinates: Array.from(textCoordinates.entries())
    }));

    return { success: true, status: "PROCESSING" };
  } catch (error) {
    console.error('Background processing error:', error);
    
    // Atualizar contrato com erro
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'ERROR', // Em maiúsculas
        metadata: {
          error: error instanceof Error ? error.message : 'Processing failed'
        }
      }
    });
    
    return { success: false, error: error instanceof Error ? error.message : 'Processing failed' };
  }
}

export async function processAnalysisQueue() {
  try {
    // Pega o próximo item da fila (sem remover)
    const queueItem = await redis.lindex('contract-analysis-queue', 0);
    
    if (!queueItem) {
      return { success: true, message: "No items in queue" };
    }
    
    const { contractId, userId, text, textCoordinates } = JSON.parse(queueItem);
    
    // Atualizar status para ANALYZING (em maiúsculas)
    await prisma.contract.update({
      where: { id: contractId },
      data: { status: "ANALYZING" }
    });
    
    // Reconstruir o Map de coordenadas
    const coordsMap = new Map(textCoordinates);
    
    // Realizar a análise
    const analysisResult = await analyzeContract(text, coordsMap);
    
    // Atualizar o contrato com os resultados
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        issues: JSON.parse(JSON.stringify(analysisResult.issues)),
        suggestedClauses: JSON.parse(JSON.stringify(analysisResult.suggestedClauses)),
        status: "UNDER_REVIEW", // Em maiúsculas
        updatedAt: new Date()
      }
    });
    
    // Remover o item da fila após processamento bem-sucedido
    await redis.lpop('contract-analysis-queue');
    
    return { success: true, contractId };
    
  } catch (error) {
    console.error('Queue processing error:', error);
    
    // Tentar obter o contractId do item atual
    try {
      const queueItem = await redis.lindex('contract-analysis-queue', 0);
      if (queueItem) {
        const { contractId } = JSON.parse(queueItem);
        
        // Atualizar contrato com erro
        await prisma.contract.update({
          where: { id: contractId },
          data: {
            status: 'ERROR', // Em maiúsculas
            metadata: {
              error: error instanceof Error ? error.message : 'Analysis failed'
            }
          }
        });
        
        // Remover o item com erro da fila
        await redis.lpop('contract-analysis-queue');
      }
    } catch (innerError) {
      console.error('Error handling queue failure:', innerError);
    }
    
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Queue processing failed' 
    };
  }
}
```


## 3. Atualizando o componente de monitoramento

```typescript:src/components/contracts/ContractProcessingMonitor.tsx
'use client';

import { useState, useEffect } from 'react';
import { Progress } from '@/components/ui/progress';
import { toast } from 'sonner';

interface ContractProcessingMonitorProps {
  contractId: string;
  initialStatus: string;
  onComplete?: () => void;
}

export function ContractProcessingMonitor({
  contractId,
  initialStatus,
  onComplete
}: ContractProcessingMonitorProps) {
  const [status, setStatus] = useState(initialStatus);
  const [progress, setProgress] = useState(initialStatus === 'UNDER_REVIEW' ? 100 : 35);
  const [isComplete, setIsComplete] = useState(initialStatus === 'UNDER_REVIEW');

  useEffect(() => {
    if (isComplete) return;

    // Simular progresso visual enquanto aguarda
    const progressInterval = setInterval(() => {
      setProgress(prev => {
        // Limitar o progresso máximo a 95% até que a análise seja concluída
        if (prev < 95) {
          return prev + 0.2;
        }
        return prev;
      });
    }, 300);

    // Verificar o status do contrato periodicamente
    const statusInterval = setInterval(async () => {
      try {
        const response = await fetch(`/api/contracts/${contractId}/status`);
        const data = await response.json();
        
        setStatus(data.status);
        
        if (data.status === 'UNDER_REVIEW') {
          clearInterval(progressInterval);
          clearInterval(statusInterval);
          setProgress(100);
          setIsComplete(true);
          toast.success('Contract analysis complete!');
          if (onComplete) onComplete();
        } else if (data.status === 'ERROR') {
          clearInterval(progressInterval);
          clearInterval(statusInterval);
          toast.error('Error analyzing contract. Please try again.');
        }
      } catch (error) {
        console.error('Error checking contract status:', error);
      }
    }, 5000); // Verificar a cada 5 segundos

    return () => {
      clearInterval(progressInterval);
      clearInterval(statusInterval);
    };
  }, [contractId, isComplete, onComplete]);

  if (isComplete) return null;

  return (
    <div className="w-full p-4 bg-blue-900/20 rounded-lg mb-6">
      <div className="mb-2 flex justify-between items-center">
        <h3 className="text-white font-medium">Analyzing your contract</h3>
        <span className="text-sm text-blue-300">{Math.round(progress)}%</span>
      </div>
      <Progress value={progress} className="h-2 mb-2" />
      <p className="text-sm text-blue-300">
        {status === 'UPLOADING' && 'Uploading your contract...'}
        {status === 'PROCESSING' && 'Processing your contract...'}
        {status === 'ANALYZING' && 'AI is analyzing your contract...'}
        {status === 'ERROR' && 'Error analyzing your contract. Please try again.'}
      </p>
    </div>
  );
}
```


## 4. Atualizando a página do contrato

```typescript:src/app/(protected)/contracts/[id]/page.tsx
import { ContractProcessingMonitor } from '@/components/contracts/ContractProcessingMonitor';

// No seu componente de página:
export default async function ContractPage({ params }: { params: { id: string } }) {
  const contract = await getContract(params.id);
  
  // Verificar se o contrato está em processamento (usando valores em maiúsculas)
  const isProcessing = ['UPLOADING', 'PROCESSING', 'ANALYZING'].includes(contract.status);
  
  return (
    <div>
      {isProcessing && (
        <ContractProcessingMonitor 
          contractId={contract.id} 
          initialStatus={contract.status} 
          onComplete={() => {
            // Opcional: recarregar a página quando a análise for concluída
            window.location.reload();
          }}
        />
      )}
      
      {/* Resto do conteúdo da página */}
      {contract.status === 'UNDER_REVIEW' ? (
        // Mostrar os resultados da análise
        <div>
          {/* Conteúdo da análise */}
        </div>
      ) : (
        // Mostrar mensagem de espera se ainda estiver processando
        !isProcessing && contract.status === 'ERROR' && (
          <div className="text-center py-12">
            <p>Contract analysis failed. Please try uploading again.</p>
          </div>
        )
      )}
    </div>
  );
}
```


Agora que você atualizou a enum no banco de dados para aceitar tanto valores em maiúsculas quanto em minúsculas, o código deve funcionar corretamente usando os valores em maiúsculas conforme seu schema Prisma original.

Esta solução mantém a consistência com seu código existente e evita a necessidade de fazer alterações extensivas em todo o sistema.

---

_**User**_

ainda com erro.

Pode ser outro campo? O que acha de adicionar um log para vermos com clareza como o dado esta vindo

---

_**Assistant**_





# Adicionando logs detalhados para depurar o problema

Vamos criar uma versão da API de upload com logs detalhados para identificar exatamente o que está causando o erro:

```typescript:src/app/api/contracts/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { PrismaClient } from '@prisma/client';
import { processContractInBackground } from '@/lib/process';

const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'], // Ativar logs detalhados do Prisma
});

export async function POST(req: NextRequest) {
  try {
    console.log("=== INICIANDO UPLOAD DE CONTRATO ===");
    
    const session = await getServerSession(authOptions);
    const userId = session?.user?.id;
    console.log("UserId:", userId);

    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      console.log("Erro: Nenhum arquivo fornecido");
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    console.log("Arquivo recebido:", {
      name: file.name,
      type: file.type,
      size: file.size
    });

    // Verificar os valores da enum no banco de dados
    console.log("Verificando valores da enum contract_status...");
    try {
      const enumValues = await prisma.$queryRaw`SELECT enum_range(NULL::contract_status)`;
      console.log("Valores da enum contract_status:", enumValues);
    } catch (enumError) {
      console.error("Erro ao verificar enum:", enumError);
    }

    // Tentar criar o contrato com 'draft' em minúsculas
    console.log("Tentando criar contrato com status 'draft'...");
    try {
      const contract = await prisma.contract.create({
        data: {
          title: file.name,
          fileName: file.name,
          fileType: file.type,
          content: "",
          status: 'draft', // Tentar com minúsculas
          userId: userId,
          numPages: 0,
          issues: [],
          suggestedClauses: [],
          metadata: {}
        }
      });

      console.log("Contrato criado com sucesso:", {
        id: contract.id,
        title: contract.title,
        status: contract.status
      });

      // Iniciar o processamento em background
      await processContractInBackground(contract.id, file, userId || '');

      return NextResponse.json({
        success: true,
        contract: {
          id: contract.id,
          name: contract.title,
          status: contract.status
        }
      });
    } catch (createError) {
      console.error("Erro ao criar contrato com 'draft':", createError);
      
      // Tentar com SQL bruto para ver se funciona
      console.log("Tentando criar contrato com SQL bruto...");
      try {
        const contractId = crypto.randomUUID();
        await prisma.$executeRaw`
          INSERT INTO "Contract" (
            "id", "title", "content", "status", "fileUrl", "fileName", "fileType", 
            "userId", "numPages", "createdAt", "updatedAt", "issues", "suggestedClauses", "metadata"
          ) 
          VALUES (
            ${contractId}::uuid, ${file.name}, '', 'draft', '', ${file.name}, 
            ${file.type}, ${userId}::uuid, 0, NOW(), NOW(), '[]'::jsonb, '[]'::jsonb, '{}'::jsonb
          )
        `;
        
        console.log("Contrato criado com SQL bruto, ID:", contractId);
        
        const contract = await prisma.contract.findUnique({
          where: { id: contractId }
        });
        
        if (!contract) {
          throw new Error("Contrato não encontrado após criação");
        }
        
        // Iniciar o processamento em background
        await processContractInBackground(contractId, file, userId || '');
        
        return NextResponse.json({
          success: true,
          contract: {
            id: contract.id,
            name: contract.title,
            status: contract.status
          }
        });
      } catch (sqlError) {
        console.error("Erro ao criar contrato com SQL bruto:", sqlError);
        throw sqlError; // Propagar o erro para o tratamento final
      }
    }
  } catch (error) {
    console.error("=== ERRO FINAL NO UPLOAD ===");
    console.error(error);
    
    // Tentar extrair mais informações do erro
    let errorMessage = "Upload failed";
    let errorDetails = {};
    
    if (error instanceof Error) {
      errorMessage = error.message;
      errorDetails = {
        name: error.name,
        stack: error.stack,
      };
      
      // Se for um erro do Prisma, tentar extrair mais detalhes
      if (error.name.includes('Prisma')) {
        // @ts-ignore
        if (error.meta) {
          // @ts-ignore
          errorDetails = { ...errorDetails, meta: error.meta };
        }
      }
    }
    
    console.error("Detalhes do erro:", errorDetails);
    
    return NextResponse.json(
      { 
        success: false, 
        error: errorMessage,
        details: errorDetails
      }, 
      { status: 500 }
    );
  }
}
```


Esta versão da API:

1. Adiciona logs detalhados em cada etapa do processo
2. Verifica os valores da enum diretamente no banco de dados
3. Tenta criar o contrato com 'draft' em minúsculas
4. Se falhar, tenta com SQL bruto como alternativa
5. Captura e registra detalhes completos de qualquer erro

Depois de executar esta versão, você terá logs detalhados que mostrarão exatamente o que está acontecendo e qual é o problema específico.

## Verificando o schema do banco de dados

Além disso, você pode verificar diretamente o schema do banco de dados para entender a restrição exata:

```sql
-- Execute estas consultas no seu banco de dados PostgreSQL
-- Para ver os valores da enum
SELECT enum_range(NULL::contract_status);

-- Para ver a definição da restrição
SELECT conname, pg_get_constraintdef(oid) 
FROM pg_constraint 
WHERE conname = 'contract_status_check';

-- Para ver a definição da tabela Contract
\d "Contract"
```


Após obter esses logs e informações, poderemos identificar com precisão o que está causando o erro e como resolvê-lo definitivamente.

---

_**User**_

o @UploadZone.tsx não está chegando no @route.ts não sei porque mas ele nem mostra no console o "console.log("=== INICIANDO UPLOAD DE CONTRATO ===");"

Invalid `prisma.contract.create()` invocation:


Error occurred during query execution:
ConnectorError(ConnectorError { user_facing_error: None, kind: QueryError(PostgresError { code: "23514", message: "new row for relation \"Contract\" violates check constraint \"contract_status_check\"", severity: "ERROR", detail: Some("Failing row contains (59f59fd9-b8e7-4a1f-ac9e-fcb2627a587d, contrato.de_.locacao.006-7a4 - co\u{301}pia.pdf, , DRAFT, , contrato.de_.locacao.006-7a4 - co\u{301}pia.pdf, application/pdf, 1118da77-5ce1-43f6-b52e-03a11d5bd956, 2025-03-03 19:35:11.832, 2025-03-03 19:35:11.832, [], [], null, 0, [], [], {\"createdAt\": \"2025-03-03T19:35:10.284Z\", \"updatedAt\": \"2025-03-...)."), column: None, hint: None }), transient: false })
    at uploadContract (UploadZone.tsx:77:15)
    at async handleUpload (UploadZone.tsx:110:20)

---

_**Assistant**_





# Resolvendo o problema de upload no UploadZone.tsx

O problema está ocorrendo porque o componente `UploadZone.tsx` está tentando fazer o upload, mas a requisição não está chegando ao endpoint `/api/contracts/upload`. Vamos resolver isso verificando o fluxo de upload e corrigindo os problemas.

## 1. Verificando o problema de rota

Primeiro, vamos verificar se a rota está correta e se o componente está enviando a requisição para o endpoint correto.

```typescript:src/components/contracts/upload/UploadZone.tsx
// Modificar a função uploadContract para adicionar logs e verificar se a requisição está sendo enviada corretamente
const uploadContract = async (formData: FormData) => {
  try {
    console.log("Iniciando upload para /api/contracts/upload");
    
    // Verificar o conteúdo do FormData
    console.log("FormData contém arquivo:", formData.has('file'));
    const fileFromForm = formData.get('file') as File;
    console.log("Detalhes do arquivo:", {
      name: fileFromForm?.name,
      type: fileFromForm?.type,
      size: fileFromForm?.size
    });
    
    const response = await fetch('/api/contracts/upload', {
      method: 'POST',
      body: formData,
      signal: AbortSignal.timeout(300000), // 5 minutes timeout
    });

    console.log("Resposta recebida:", {
      status: response.status,
      ok: response.ok,
      statusText: response.statusText
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => null);
      console.error("Erro na resposta:", errorData);
      throw new Error(errorData?.error || 'Upload failed');
    }

    const data = await response.json();
    console.log("Dados da resposta:", data);
    return data;
  } catch (err) {
    console.error('Upload error detalhado:', err);
    throw new Error(err instanceof Error ? err.message : 'Failed to upload contract');
  }
};
```


## 2. Corrigindo o problema de status no endpoint

Vamos modificar o endpoint para aceitar qualquer valor de status, usando SQL bruto para contornar a restrição:

```typescript:src/app/api/contracts/upload/route.ts
import { NextResponse, NextRequest } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { PrismaClient } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import crypto from 'crypto';
import { processContractInBackground } from '@/lib/process';

export const maxDuration = 60; // 60 segundos
export const dynamic = 'force-dynamic';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

// Create a new instance for this route
const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'], // Ativar logs detalhados
});

export async function POST(req: NextRequest) {
  try {
    console.log("=== INICIANDO UPLOAD DE CONTRATO ===");
    
    const session = await getServerSession(authOptions);
    const userId = session?.user?.id;

    if (!userId) {
      return NextResponse.json({ 
        success: false, 
        error: 'User not authenticated' 
      }, { status: 401 });
    }

    console.log("UserId:", userId);
    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      console.log("Erro: Nenhum arquivo fornecido");
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    console.log("Arquivo recebido:", {
      name: file.name,
      type: file.type,
      size: file.size
    });

    // Gerar um ID para o contrato
    const contractId = crypto.randomUUID();
    console.log("ID do contrato gerado:", contractId);

    // Usar SQL bruto para inserir o contrato, evitando a restrição de enum
    try {
      console.log("Inserindo contrato com SQL bruto...");
      await prisma.$executeRaw`
        INSERT INTO "Contract" (
          "id", "title", "content", "status", "fileUrl", "fileName", "fileType", 
          "userId", "numPages", "createdAt", "updatedAt", "issues", "suggestedClauses", "metadata"
        ) 
        VALUES (
          ${contractId}::uuid, ${file.name}, '', 'draft', '', ${file.name}, 
          ${file.type}, ${userId}::uuid, 0, NOW(), NOW(), '[]'::jsonb, '[]'::jsonb, '{}'::jsonb
        )
      `;
      
      console.log("Contrato inserido com sucesso via SQL bruto");
    } catch (sqlError) {
      console.error("Erro ao inserir contrato com SQL bruto:", sqlError);
      
      // Tentar com valores em maiúsculas
      console.log("Tentando inserir com valores em maiúsculas...");
      try {
        await prisma.$executeRaw`
          INSERT INTO "Contract" (
            "id", "title", "content", "status", "fileUrl", "fileName", "fileType", 
            "userId", "numPages", "createdAt", "updatedAt", "issues", "suggestedClauses", "metadata"
          ) 
          VALUES (
            ${contractId}::uuid, ${file.name}, '', 'DRAFT', '', ${file.name}, 
            ${file.type}, ${userId}::uuid, 0, NOW(), NOW(), '[]'::jsonb, '[]'::jsonb, '{}'::jsonb
          )
        `;
        
        console.log("Contrato inserido com sucesso usando 'DRAFT'");
      } catch (upperCaseError) {
        console.error("Erro ao inserir com valores em maiúsculas:", upperCaseError);
        throw upperCaseError;
      }
    }

    // Buscar o contrato criado
    const contract = await prisma.contract.findUnique({
      where: { id: contractId }
    });

    if (!contract) {
      console.error("Contrato não encontrado após criação");
      throw new Error('Failed to create contract');
    }

    console.log("Contrato recuperado:", {
      id: contract.id,
      title: contract.title,
      status: contract.status
    });

    // Iniciar o processamento em background
    console.log("Iniciando processamento em background...");
    await processContractInBackground(contract.id, file, userId || '');
    console.log("Processamento em background iniciado");

    return NextResponse.json({
      success: true,
      contract: {
        id: contract.id,
        name: contract.title,
        status: contract.status
      }
    });
  } catch (error) {
    console.error('Upload error:', error);
    return NextResponse.json(
      { success: false, error: error instanceof Error ? error.message : 'Upload failed' },
      { status: 500 }
    );
  }
}
```


## 3. Verificando o problema de CORS ou roteamento

Se o problema persistir, pode ser um problema de CORS ou roteamento no Next.js. Vamos criar um endpoint de teste simples para verificar:

```typescript:src/app/api/test/route.ts
import { NextResponse } from 'next/server';

export async function GET() {
  console.log("Endpoint de teste acessado");
  return NextResponse.json({ message: 'API funcionando corretamente' });
}

export async function POST(req: Request) {
  console.log("POST para endpoint de teste recebido");
  const data = await req.json().catch(() => ({}));
  console.log("Dados recebidos:", data);
  return NextResponse.json({ message: 'POST recebido com sucesso', data });
}
```


Teste este endpoint no navegador ou com uma ferramenta como Postman para verificar se as rotas da API estão funcionando corretamente.

## 4. Verificando o middleware

Se você tiver um middleware configurado, verifique se ele não está bloqueando as requisições para a API:

```typescript:src/middleware.ts
// Se você tiver um middleware, verifique se ele está permitindo acesso à API
export function middleware(request) {
  console.log("Middleware executado para:", request.url);
  // Resto do código...
}

export const config = {
  matcher: [
    // Certifique-se de que a rota da API não está sendo bloqueada
    // Se necessário, adicione uma exceção para '/api/contracts/upload'
  ]
};
```


## 5. Verificando o Next.js config

Verifique se o seu arquivo `next.config.js` não está configurado para bloquear rotas de API:

```javascript:next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Verifique se não há configurações que possam afetar as rotas de API
};

module.exports = nextConfig;
```


## 6. Solução alternativa: usar uma API externa

Se o problema persistir, você pode criar um endpoint de API separado (por exemplo, usando Express) e chamar esse endpoint em vez da rota interna do Next.js.

Estas modificações devem ajudar a identificar e resolver o problema de upload. O mais importante é verificar se a requisição está sendo enviada corretamente e se o endpoint está recebendo e processando a requisição.

---

_**User**_

ele deu erro ainda e no console esse foi o dado:


name
: 
"contrato.de_.locacao.006-7a4 - cópia.pdf"
size
: 
430884
type
: 
"application/pdf"

---

_**Assistant**_







# Resolvendo o problema de upload no componente UploadZone

Vamos focar no componente `UploadZone.tsx`, já que o problema parece estar ocorrendo lá. O erro indica que a requisição está sendo feita, mas há um problema com o valor do status no banco de dados.

## Modificando o UploadZone.tsx para usar um endpoint alternativo

Vamos modificar o componente para usar um endpoint alternativo que contorne o problema de restrição de enum:

```typescript:src/components/contracts/upload/UploadZone.tsx
// Modificar a função uploadContract para usar um endpoint alternativo
const uploadContract = async (formData: FormData) => {
  try {
    console.log("Iniciando upload para /api/contracts/upload-direct");
    
    // Verificar o conteúdo do FormData
    console.log("FormData contém arquivo:", formData.has('file'));
    const fileFromForm = formData.get('file') as File;
    console.log("Detalhes do arquivo:", {
      name: fileFromForm?.name,
      type: fileFromForm?.type,
      size: fileFromForm?.size
    });
    
    // Criar um objeto FormData com os dados corretos
    const newFormData = new FormData();
    newFormData.append('file', fileFromForm);
    
    // Adicionar o status como string para garantir que seja enviado corretamente
    newFormData.append('status', 'draft'); // Usar minúsculas para compatibilidade
    
    const response = await fetch('/api/contracts/upload-direct', {
      method: 'POST',
      body: newFormData,
      signal: AbortSignal.timeout(300000), // 5 minutes timeout
    });

    console.log("Resposta recebida:", {
      status: response.status,
      ok: response.ok,
      statusText: response.statusText
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => null);
      console.error("Erro na resposta:", errorData);
      throw new Error(errorData?.error || 'Upload failed');
    }

    const data = await response.json();
    console.log("Dados da resposta:", data);
    return data;
  } catch (err) {
    console.error('Upload error detalhado:', err);
    throw new Error(err instanceof Error ? err.message : 'Failed to upload contract');
  }
};
```



## Criando um novo endpoint para upload direto

Agora, vamos criar um novo endpoint que use SQL bruto para inserir o contrato, evitando o problema de enum:

```typescript:src/app/api/contracts/upload-direct/route.ts
import { NextResponse, NextRequest } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { PrismaClient } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import crypto from 'crypto';
import { processContractInBackground } from '@/lib/process';

export const maxDuration = 60; // 60 segundos
export const dynamic = 'force-dynamic';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

// Create a new instance for this route
const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'], // Ativar logs detalhados
});

export async function POST(req: NextRequest) {
  try {
    console.log("=== INICIANDO UPLOAD DIRETO DE CONTRATO ===");
    
    const session = await getServerSession(authOptions);
    const userId = session?.user?.id;

    if (!userId) {
      return NextResponse.json({ 
        success: false, 
        error: 'User not authenticated' 
      }, { status: 401 });
    }

    console.log("UserId:", userId);
    const formData = await req.formData();
    const file = formData.get('file') as File;
    const status = formData.get('status') as string || 'draft';

    if (!file) {
      console.log("Erro: Nenhum arquivo fornecido");
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    console.log("Arquivo recebido:", {
      name: file.name,
      type: file.type,
      size: file.size,
      status: status
    });

    // Gerar um ID para o contrato
    const contractId = crypto.randomUUID();
    console.log("ID do contrato gerado:", contractId);

    // Usar SQL bruto para inserir o contrato, evitando a restrição de enum
    try {
      console.log("Inserindo contrato com SQL bruto...");
      await prisma.$executeRaw`
        INSERT INTO "Contract" (
          "id", "title", "content", "status", "fileUrl", "fileName", "fileType", 
          "userId", "numPages", "createdAt", "updatedAt", "issues", "suggestedClauses", "metadata"
        ) 
        VALUES (
          ${contractId}::uuid, ${file.name}, '', ${status}, '', ${file.name}, 
          ${file.type}, ${userId}::uuid, 0, NOW(), NOW(), '[]'::jsonb, '[]'::jsonb, '{}'::jsonb
        )
      `;
      
      console.log("Contrato inserido com sucesso via SQL bruto");
    } catch (sqlError) {
      console.error("Erro ao inserir contrato com SQL bruto:", sqlError);
      
      // Tentar com valores em maiúsculas
      console.log("Tentando inserir com valores em maiúsculas...");
      try {
        await prisma.$executeRaw`
          INSERT INTO "Contract" (
            "id", "title", "content", "status", "fileUrl", "fileName", "fileType", 
            "userId", "numPages", "createdAt", "updatedAt", "issues", "suggestedClauses", "metadata"
          ) 
          VALUES (
            ${contractId}::uuid, ${file.name}, '', 'DRAFT', '', ${file.name}, 
            ${file.type}, ${userId}::uuid, 0, NOW(), NOW(), '[]'::jsonb, '[]'::jsonb, '{}'::jsonb
          )
        `;
        
        console.log("Contrato inserido com sucesso usando 'DRAFT'");
      } catch (upperCaseError) {
        console.error("Erro ao inserir com valores em maiúsculas:", upperCaseError);
        
        // Última tentativa: usar um valor que sabemos que existe na enum
        console.log("Tentando com um valor conhecido da enum...");
        try {
          // Consultar os valores da enum
          const enumValues = await prisma.$queryRaw`SELECT enum_range(NULL::contract_status)`;
          console.log("Valores da enum:", enumValues);
          
          // Usar o primeiro valor da enum
          const firstEnumValue = Array.isArray(enumValues) && enumValues.length > 0 
            ? enumValues[0][0] 
            : 'draft';
          
          console.log("Usando valor da enum:", firstEnumValue);
          
          await prisma.$executeRaw`
            INSERT INTO "Contract" (
              "id", "title", "content", "status", "fileUrl", "fileName", "fileType", 
              "userId", "numPages", "createdAt", "updatedAt", "issues", "suggestedClauses", "metadata"
            ) 
            VALUES (
              ${contractId}::uuid, ${file.name}, '', ${firstEnumValue}, '', ${file.name}, 
              ${file.type}, ${userId}::uuid, 0, NOW(), NOW(), '[]'::jsonb, '[]'::jsonb, '{}'::jsonb
            )
          `;
          
          console.log("Contrato inserido com sucesso usando valor conhecido da enum");
        } catch (finalError) {
          console.error("Erro na última tentativa:", finalError);
          throw finalError;
        }
      }
    }

    // Buscar o contrato criado
    const contract = await prisma.contract.findUnique({
      where: { id: contractId }
    });

    if (!contract) {
      console.error("Contrato não encontrado após criação");
      throw new Error('Failed to create contract');
    }

    console.log("Contrato recuperado:", {
      id: contract.id,
      title: contract.title,
      status: contract.status
    });

    // Iniciar o processamento em background
    console.log("Iniciando processamento em background...");
    await processContractInBackground(contract.id, file, userId || '');
    console.log("Processamento em background iniciado");

    return NextResponse.json({
      success: true,
      contract: {
        id: contract.id,
        name: contract.title,
        status: contract.status
      }
    });
  } catch (error) {
    console.error('Upload error:', error);
    return NextResponse.json(
      { success: false, error: error instanceof Error ? error.message : 'Upload failed' },
      { status: 500 }
    );
  }
}
```



## Solução alternativa: Modificar o UploadZone para usar um endpoint de debug

Se você preferir não criar um novo endpoint, podemos modificar o UploadZone para usar um endpoint de debug que nos ajude a entender melhor o problema:

```typescript:src/components/contracts/upload/UploadZone.tsx
// Adicionar uma função de debug para verificar os valores da enum
const checkEnumValues = async () => {
  try {
    const response = await fetch('/api/debug/check-enum');
    const data = await response.json();
    console.log("Valores da enum contract_status:", data.enumValues);
    console.log("Definição da restrição:", data.constraint);
    return data;
  } catch (error) {
    console.error("Erro ao verificar enum:", error);
    return null;
  }
};

// Modificar a função handleUpload para verificar os valores da enum antes de fazer o upload
const handleUpload = async (file: File) => {
  try {
    setLoading(true);
    setShowProcessing(true);
    
    // Verificar os valores da enum antes de fazer o upload
    console.log("Verificando valores da enum...");
    const enumData = await checkEnumValues();
    console.log("Dados da enum:", enumData);
    
    // Começar do 0 apenas se não houver progresso anterior
    if (progress === 0) {
      setProgress(0);
    }
    
    // Upload progress mais gradual (0-30%)
    let uploadProgress = 0;
    const uploadTimer = setInterval(() => {
      if (uploadProgress < 30) {
        uploadProgress += 0.5;
        setProgress(prev => Math.max(prev, uploadProgress));
      }
    }, 100);

    const formData = new FormData();
    formData.append('file', file);
    
    // Adicionar o status como string para garantir que seja enviado corretamente
    // Usar o valor que sabemos que funciona com base na verificação da enum
    const statusToUse = enumData?.enumValues?.[0]?.[0] || 'draft';
    formData.append('status', statusToUse);
    console.log("Usando status:", statusToUse);
    
    const data = await uploadContract(formData);
    clearInterval(uploadTimer);

    // ... resto do código ...
  } catch (error) {
    // ... código de tratamento de erro ...
  }
};
```



## Criando um endpoint de debug para verificar os valores da enum

```typescript:src/app/api/debug/check-enum/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function GET() {
  try {
    // Consultar os valores aceitos pela enum
    const result = await prisma.$queryRaw`
      SELECT enum_range(NULL::contract_status);
    `;
    
    // Consultar a definição da restrição
    const constraint = await prisma.$queryRaw`
      SELECT pg_get_constraintdef(oid) 
      FROM pg_constraint 
      WHERE conname = 'contract_status_check';
    `;
    
    return NextResponse.json({ 
      enumValues: result,
      constraint
    });
  } catch (error) {
    console.error('Debug error:', error);
    return NextResponse.json({ error: String(error) }, { status: 500 });
  }
}
```



Estas modificações devem ajudar a identificar e resolver o problema de upload. O mais importante é verificar quais valores são aceitos pela enum no banco de dados e usar esses valores ao criar o contrato.

---



---

