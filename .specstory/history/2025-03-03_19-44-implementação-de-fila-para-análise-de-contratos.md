<!-- Generated by SpecStory -->

# Implementação de Fila para Análise de Contratos (2025-03-03 16:44:02)

_**User**_

Hey chat, eu estou enfrentando timeout ao analisar um contrato com IA ao subir para produção.

O que acha de deixarmos a parte da Analise de IA de fundo (via fila) já dentro da página do contrato? Com um loading até finalizar.

Se fizermos via Fila a etapa de analise que chamamos no @analyzeContract() dentro do @process.ts na linha 172, não resolveria?

Pensei em usar o upstash direto com o Vercel (até iniciei a implementação mas não finalizei).

O que você acha desta solução para evitar os problemas de timeout? Por favor analise com cuidado e me traga a melhor solução e forma de implementar sem@https://upstash.com/docs/redis/quickstarts/nextjs-app-router @https://upstash.com/docs/redis/howto/vercelintegration 

além disso eu já tenho alguns status populados no meu @schema.prisma 
"enum contract_status {
  draft
  under_review
  approved
  rejected
}
"

---

_**Assistant**_

# Implementando uma Fila com Upstash Redis para Análise de Contratos

Sua ideia de mover a análise de IA para um processo em segundo plano usando uma fila é excelente para resolver o problema de timeout. Isso é especialmente importante em ambientes serverless como o Vercel, onde as funções têm limites de tempo de execução.

Vou propor uma solução usando Upstash Redis como sistema de fila, que se integra perfeitamente com o Next.js e Vercel.

## Plano de Implementação

1. Configurar Upstash Redis com Vercel
2. Criar uma estrutura de fila para processar análises de contratos
3. Modificar o fluxo atual para enfileirar a análise e verificar o status
4. Implementar um worker para processar a fila (usando API Routes)

## 1. Configuração do Upstash Redis

Primeiro, instale as dependências necessárias:

```bash
npm install @upstash/redis
```

## 2. Modificações no Schema Prisma

Vamos adicionar um novo status ao enum existente para rastrear contratos em análise:

```prisma:prisma/schema.prisma
// ... existing code ...

enum contract_status {
  draft
  under_review
  approved
  rejected
  processing  // Novo status para indicar análise em andamento
  error       // Status para quando a análise falha
}

// ... existing code ...
```

## 3. Implementação da Solução

### Criando o cliente Redis

```typescript:src/lib/redis.ts
import { Redis } from '@upstash/redis';

// Cria uma instância do Redis usando variáveis de ambiente
// (configuradas pela integração Vercel-Upstash)
export const redis = Redis.fromEnv();

// Nome da fila para análise de contratos
export const ANALYSIS_QUEUE = 'contract-analysis-queue';
```

### Modificando o processamento de contratos

```typescript:src/lib/process.ts
// ... existing code ...
import { redis, ANALYSIS_QUEUE } from '@/lib/redis';

// ... existing code ...

export async function processContractInBackground(
  contractId: string, 
  file: File, 
  userId: string
) {
  try {
    // 1. Upload do arquivo para o Supabase
    const sanitizedFileName = sanitizeFileName(file.name);
    const uniqueFileName = `${Date.now()}-${sanitizedFileName}`;
    const buffer = await file.arrayBuffer();

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('contracts')
      .upload(uniqueFileName, buffer, {
        contentType: file.type,
        upsert: false
      });

    if (uploadError) throw uploadError;

    const { data: { publicUrl } } = supabase.storage
      .from('contracts')
      .getPublicUrl(uploadData.path);

    // 2. Extrair texto e coordenadas
    const { text, numPages, textCoordinates } = await extractTextContent(file);

    // 3. Atualização: URL do arquivo, conteúdo e status para "processing"
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        fileUrl: publicUrl,
        content: text,
        numPages: numPages,
        status: "processing", // Atualiza para status de processamento
        metadata: {
          pageCount: numPages,
          processingStartedAt: new Date()
        }
      }
    });

    // 4. Adicionar à fila de análise em vez de processar imediatamente
    await redis.lpush(ANALYSIS_QUEUE, JSON.stringify({
      contractId,
      userId,
      textCoordinates: Array.from(textCoordinates.entries())
    }));

    // Retorna imediatamente, a análise será processada em segundo plano
    return { success: true, contractId };

  } catch (error) {
    console.error('Contract processing error:', error);
    
    // Atualizar contrato com erro
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'error',
        metadata: {
          error: error instanceof Error ? error.message : 'Processing failed'
        }
      }
    });
    
    throw error;
  }
}

// Nova função para processar um item da fila
export async function processQueueItem(item: any) {
  const { contractId, textCoordinates } = item;
  
  try {
    // Buscar o contrato do banco de dados
    const contract = await prisma.contract.findUnique({
      where: { id: contractId }
    });
    
    if (!contract) {
      throw new Error(`Contract not found: ${contractId}`);
    }
    
    // Reconstruir o Map de coordenadas
    const textCoordsMap = new Map(textCoordinates);
    
    // Executar a análise
    const analysisResult = await analyzeContract(contract.content, textCoordsMap);
    
    // Atualizar o contrato com os resultados
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        issues: JSON.parse(JSON.stringify(analysisResult.issues)),
        suggestedClauses: JSON.parse(JSON.stringify(analysisResult.suggestedClauses)),
        status: "under_review",
        metadata: {
          ...JSON.parse(contract.metadata as string),
          analysisCompletedAt: new Date()
        }
      }
    });
    
    return { success: true, contractId };
  } catch (error) {
    console.error('Queue processing error:', error);
    
    // Atualizar contrato com erro
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'error',
        metadata: {
          ...JSON.parse((contract?.metadata as string) || '{}'),
          error: error instanceof Error ? error.message : 'Analysis failed',
          errorAt: new Date()
        }
      }
    });
    
    throw error;
  }
}
```

### Criando um Worker API Route para processar a fila

```typescript:src/app/api/worker/contract-analysis/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { redis, ANALYSIS_QUEUE } from '@/lib/redis';
import { processQueueItem } from '@/lib/process';

// Proteger a rota com uma chave secreta
const API_SECRET = process.env.WORKER_API_SECRET;

export async function POST(req: NextRequest) {
  try {
    // Verificar autenticação
    const authorization = req.headers.get('authorization');
    if (!authorization || authorization !== `Bearer ${API_SECRET}`) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Obter um item da fila
    const queueItem = await redis.rpop(ANALYSIS_QUEUE);
    
    if (!queueItem) {
      return NextResponse.json({ message: 'No items in queue' });
    }
    
    // Processar o item
    const item = JSON.parse(queueItem);
    await processQueueItem(item);
    
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Worker error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
```

### Criando um endpoint para verificar o status da análise

```typescript:src/app/api/contracts/[id]/status/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

const prisma = new PrismaClient();

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const contractId = params.id;
    
    const contract = await prisma.contract.findUnique({
      where: { id: contractId },
      select: {
        id: true,
        status: true,
        metadata: true,
        issues: true,
        suggestedClauses: true,
        userId: true
      }
    });
    
    if (!contract) {
      return NextResponse.json({ error: 'Contract not found' }, { status: 404 });
    }
    
    // Verificar se o usuário tem acesso a este contrato
    if (contract.userId !== session.user.id) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }
    
    return NextResponse.json({
      id: contract.id,
      status: contract.status,
      metadata: contract.metadata,
      isComplete: contract.status === 'under_review' || contract.status === 'error',
      hasResults: contract.issues.length > 0 || contract.suggestedClauses.length > 0
    });
  } catch (error) {
    console.error('Status check error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
```

### Configurando um cron job para processar a fila

Crie um arquivo para configurar um cron job no Vercel:

```typescript:src/app/api/cron/process-queue/route.ts
import { NextResponse } from 'next/server';
import { redis, ANALYSIS_QUEUE } from '@/lib/redis';

// Função para chamar o worker
async function callWorker() {
  const workerUrl = `${process.env.NEXT_PUBLIC_APP_URL}/api/worker/contract-analysis`;
  
  try {
    const response = await fetch(workerUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.WORKER_API_SECRET}`
      }
    });
    
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Worker failed: ${error}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error calling worker:', error);
    throw error;
  }
}

export async function GET() {
  try {
    // Verificar se há itens na fila
    const queueLength = await redis.llen(ANALYSIS_QUEUE);
    
    if (queueLength === 0) {
      return NextResponse.json({ message: 'No items in queue' });
    }
    
    // Processar até 5 itens por execução
    const results = [];
    const maxItems = Math.min(5, queueLength);
    
    for (let i = 0; i < maxItems; i++) {
      try {
        const result = await callWorker();
        results.push(result);
      } catch (error) {
        console.error(`Failed to process item ${i}:`, error);
        break;
      }
    }
    
    return NextResponse.json({
      processed: results.length,
      remaining: await redis.llen(ANALYSIS_QUEUE)
    });
  } catch (error) {
    console.error('Cron job error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

// Configuração para o Vercel Cron
export const config = {
  runtime: 'edge',
  regions: ['iad1'],  // Escolha a região mais próxima do seu banco de dados
};
```

### Atualizando a interface do usuário para mostrar o status de processamento

Você precisará atualizar a interface do usuário para verificar periodicamente o status da análise. Aqui está um exemplo de como você pode fazer isso:

```typescript:src/app/contracts/[id]/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { useParams } from 'next/navigation';
import { Contract } from '@prisma/client';

export default function ContractPage() {
  const { id } = useParams();
  const [contract, setContract] = useState<Contract | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Função para buscar o status do contrato
  const fetchContractStatus = async () => {
    try {
      const response = await fetch(`/api/contracts/${id}/status`);
      
      if (!response.ok) {
        throw new Error('Failed to fetch contract status');
      }
      
      const data = await response.json();
      
      // Atualizar o contrato com os novos dados
      setContract(prev => prev ? { ...prev, ...data } : data);
      
      // Se a análise ainda estiver em andamento, continuar verificando
      if (data.status === 'processing') {
        setTimeout(fetchContractStatus, 5000); // Verificar a cada 5 segundos
      } else {
        // Análise concluída, buscar o contrato completo
        fetchContract();
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      setLoading(false);
    }
  };

  // Função para buscar os detalhes completos do contrato
  const fetchContract = async () => {
    try {
      const response = await fetch(`/api/contracts/${id}`);
      
      if (!response.ok) {
        throw new Error('Failed to fetch contract');
      }
      
      const data = await response.json();
      setContract(data);
      setLoading(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      setLoading(false);
    }
  };

  useEffect(() => {
    // Iniciar verificando o status
    fetchContractStatus();
  }, [id]);

  // Renderizar diferentes estados com base no status do contrato
  if (loading) {
    return <div>Loading contract details...</div>;
  }

  if (error) {
    return <div>Error: {error}</div>;
  }

  if (!contract) {
    return <div>Contract not found</div>;
  }

  // Renderizar com base no status
  if (contract.status === 'processing') {
    return (
      <div>
        <h1>{contract.title}</h1>
        <div className="processing-indicator">
          <p>Analyzing your contract...</p>
          <div className="spinner"></div>
          <p>This may take a few minutes. You can safely leave this page and come back later.</p>
        </div>
      </div>
    );
  }

  if (contract.status === 'error') {
    return (
      <div>
        <h1>{contract.title}</h1>
        <div className="error-message">
          <p>There was an error analyzing your contract.</p>
          <p>{contract.metadata?.error || 'Unknown error'}</p>
          <button onClick={() => {/* Lógica para tentar novamente */}}>
            Try Again
          </button>
        </div>
      </div>
    );
  }

  // Renderizar o contrato normal com resultados da análise
  return (
    <div>
      <h1>{contract.title}</h1>
      {/* Resto da interface do contrato */}
    </div>
  );
}
```

## 4. Configuração do Vercel Cron

Para configurar o cron job no Vercel, adicione o seguinte ao seu arquivo `vercel.json`:

```json:vercel.json
{
  "crons": [
    {
      "path": "/api/cron/process-queue",
      "schedule": "*/5 * * * *"
    }
  ]
}
```

Isso executará o cron job a cada 5 minutos para processar itens na fila.

## Conclusão

Esta solução resolve o problema de timeout ao:

1. Separar o upload e processamento inicial do arquivo da análise de IA intensiva
2. Usar uma fila Redis para gerenciar os trabalhos de análise
3. Processar os itens da fila em segundo plano através de um worker
4. Fornecer feedback em tempo real ao usuário sobre o status da análise

A implementação é compatível com o ambiente serverless do Vercel e aproveita a integração com o Upstash Redis para gerenciamento de filas. O status `processing` adicionado ao enum existente permite rastrear facilmente o progresso da análise.

Esta abordagem também é escalável - à medida que mais usuários enviam contratos para análise, a fila gerencia a carga de trabalho e processa os itens de forma assíncrona, sem bloquear a interface do usuário ou causar timeouts.

---

_**User**_

ótimo apliquei tudo exceto o passo para atualizar o page.tsx que não selecionou o arquivo correto. Esse é o correto

---

_**Assistant**_

Vou atualizar o componente de página para o arquivo correto, considerando a estrutura de pastas que você está usando.

```typescript:src/app/(protected)/contracts/[id]/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { useParams } from 'next/navigation';
import { Contract } from '@prisma/client';
import { Loader2 } from 'lucide-react';

export default function ContractPage() {
  const { id } = useParams();
  const [contract, setContract] = useState<Contract | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Função para buscar o status do contrato
  const fetchContractStatus = async () => {
    try {
      const response = await fetch(`/api/contracts/${id}/status`);
      
      if (!response.ok) {
        throw new Error('Failed to fetch contract status');
      }
      
      const data = await response.json();
      
      // Atualizar o contrato com os novos dados
      setContract(prev => prev ? { ...prev, ...data } : data);
      
      // Se a análise ainda estiver em andamento, continuar verificando
      if (data.status === 'processing') {
        setTimeout(fetchContractStatus, 5000); // Verificar a cada 5 segundos
      } else {
        // Análise concluída, buscar o contrato completo
        fetchContract();
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      setLoading(false);
    }
  };

  // Função para buscar os detalhes completos do contrato
  const fetchContract = async () => {
    try {
      const response = await fetch(`/api/contracts/${id}`);
      
      if (!response.ok) {
        throw new Error('Failed to fetch contract');
      }
      
      const data = await response.json();
      setContract(data);
      setLoading(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      setLoading(false);
    }
  };

  useEffect(() => {
    // Iniciar verificando o status
    fetchContractStatus();
  }, [id]);

  // Renderizar diferentes estados com base no status do contrato
  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <div className="text-center">
          <Loader2 className="h-8 w-8 animate-spin mx-auto mb-4 text-indigo-600" />
          <p className="text-gray-600">Loading contract details...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <div className="text-center bg-red-50 p-6 rounded-lg max-w-md">
          <div className="text-red-500 text-xl mb-2">Error</div>
          <p className="text-gray-700">{error}</p>
        </div>
      </div>
    );
  }

  if (!contract) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <div className="text-center bg-gray-50 p-6 rounded-lg max-w-md">
          <p className="text-gray-700">Contract not found</p>
        </div>
      </div>
    );
  }

  // Renderizar com base no status
  if (contract.status === 'processing') {
    return (
      <div className="container mx-auto py-8 px-4">
        <h1 className="text-2xl font-bold mb-6">{contract.title || 'Contract Analysis'}</h1>
        <div className="bg-white rounded-xl p-8 shadow-sm border border-gray-100 text-center">
          <Loader2 className="h-12 w-12 animate-spin mx-auto mb-4 text-indigo-600" />
          <h2 className="text-xl font-semibold mb-2">Analyzing your contract...</h2>
          <p className="text-gray-600 mb-4">
            Our AI is carefully reviewing your document. This may take a few minutes.
          </p>
          <div className="bg-indigo-50 p-4 rounded-lg inline-block">
            <p className="text-indigo-700 text-sm">
              You can safely leave this page and come back later. We'll continue processing your contract.
            </p>
          </div>
        </div>
      </div>
    );
  }

  if (contract.status === 'error') {
    return (
      <div className="container mx-auto py-8 px-4">
        <h1 className="text-2xl font-bold mb-6">{contract.title || 'Contract Analysis'}</h1>
        <div className="bg-white rounded-xl p-8 shadow-sm border border-red-100 text-center">
          <div className="w-16 h-16 bg-red-50 rounded-full flex items-center justify-center mx-auto mb-4">
            <AlertCircle className="h-8 w-8 text-red-500" />
          </div>
          <h2 className="text-xl font-semibold mb-2 text-red-600">Analysis Error</h2>
          <p className="text-gray-700 mb-6">
            {contract.metadata?.error || 'There was an error analyzing your contract.'}
          </p>
          <button 
            onClick={() => {
              setLoading(true);
              // Aqui você pode implementar a lógica para tentar novamente
              // Por exemplo, chamar uma API para recolocar o contrato na fila
              fetch(`/api/contracts/${id}/reanalyze`, { method: 'POST' })
                .then(() => fetchContractStatus())
                .catch(err => {
                  setError(err instanceof Error ? err.message : 'Failed to restart analysis');
                  setLoading(false);
                });
            }}
            className="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition-colors"
          >
            Try Again
          </button>
        </div>
      </div>
    );
  }

  // Renderizar o contrato normal com resultados da análise
  // Aqui você pode manter sua interface existente para exibir o contrato
  return (
    <div className="container mx-auto py-8 px-4">
      <h1 className="text-2xl font-bold mb-6">{contract.title || 'Contract Analysis'}</h1>
      {/* Resto da interface do contrato */}
      <div className="bg-white rounded-xl p-8 shadow-sm border border-gray-100">
        <div className="mb-4">
          <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
            {contract.status}
          </span>
        </div>
        
        {/* Aqui você pode renderizar os detalhes do contrato, issues, etc. */}
        {contract.issues && contract.issues.length > 0 && (
          <div className="mt-6">
            <h2 className="text-lg font-semibold mb-3">Issues Found</h2>
            {/* Renderizar as issues */}
          </div>
        )}
        
        {contract.suggestedClauses && contract.suggestedClauses.length > 0 && (
          <div className="mt-6">
            <h2 className="text-lg font-semibold mb-3">Suggested Clauses</h2>
            {/* Renderizar as cláusulas sugeridas */}
          </div>
        )}
      </div>
    </div>
  );
}
```

Esta implementação:

1. Verifica periodicamente o status do contrato quando está em processamento
2. Exibe diferentes interfaces com base no status (loading, processing, error, ou completo)
3. Fornece feedback visual claro para o usuário sobre o que está acontecendo
4. Inclui um botão "Try Again" para casos de erro, que pode ser conectado a um endpoint para recolocar o contrato na fila

Você precisará implementar o endpoint `/api/contracts/[id]/reanalyze` se quiser oferecer a funcionalidade de tentar novamente. Esse endpoint pode simplesmente redefinir o status do contrato para "processing" e adicioná-lo novamente à fila de análise.

---

_**User**_

legal! Não mude nada na interface atual, apenas mexa nessa parte do esperar da fila, eu vi que vc deletou algumas coisas, por favor tenha cuidado para não remover. 

---

_**Assistant**_



Entendi! Vou modificar apenas a parte relacionada à verificação do status da fila, mantendo toda a interface atual intacta. Vou fazer uma edição mais focada no arquivo existente.

```typescript:src/app/(protected)/contracts/[id]/page.tsx
// ... existing code ...

export default function ContractPage() {
  const params = useParams();
  const router = useRouter();
  const { data: session, status } = useSession();
  const [contract, setContract] = useState<Contract | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [showReview, setShowReview] = useState(false);

  useEffect(() => {
    if (status === "loading") return;

    const fetchContract = async () => {
      try {
        const response = await fetch(`/api/contracts/${params.id}`);
        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to fetch contract');
        }

        const transformedContract: Contract = {
          id: data.id,
          userId: data.userId,
          content: data.content,
          fileUrl: data.fileUrl,
          fileType: data.fileType,
          issues: typeof data.issues === 'string'
            ? JSON.parse(data.issues)
            : data.issues || [],
          suggestedClauses: typeof data.suggestedClauses === 'string'
            ? JSON.parse(data.suggestedClauses)
            : data.suggestedClauses || [],
          status: data.status,
          metadata: data.metadata || { pageCount: data.numPages || 1, createdAt: new Date(), updatedAt: new Date() },
          fileName: data.fileName
        };

        setContract(transformedContract);
        
        // Se o contrato estiver em processamento, verificar o status periodicamente
        if (transformedContract.status === 'processing') {
          setTimeout(() => checkContractStatus(transformedContract.id), 5000);
        }
      } catch (error) {
        console.error('Error in fetchContract:', error);
        setError(error instanceof Error ? error.message : 'Failed to load contract');
      } finally {
        setLoading(false);
      }
    };

    if (params.id && session?.user) {
      fetchContract();
    }
  }, [params.id, session?.user, status]);

  // Nova função para verificar o status do contrato em processamento
  const checkContractStatus = async (contractId: string) => {
    try {
      const response = await fetch(`/api/contracts/${contractId}/status`);
      
      if (!response.ok) {
        throw new Error('Failed to check contract status');
      }
      
      const data = await response.json();
      
      // Se o contrato ainda estiver em processamento, continuar verificando
      if (data.status === 'processing') {
        setTimeout(() => checkContractStatus(contractId), 5000);
      } else {
        // Análise concluída, buscar o contrato completo
        const contractResponse = await fetch(`/api/contracts/${contractId}`);
        const contractData = await contractResponse.json();
        
        if (!contractResponse.ok) {
          throw new Error(contractData.error || 'Failed to fetch updated contract');
        }
        
        const transformedContract: Contract = {
          id: contractData.id,
          userId: contractData.userId,
          content: contractData.content,
          fileUrl: contractData.fileUrl,
          fileType: contractData.fileType,
          issues: typeof contractData.issues === 'string'
            ? JSON.parse(contractData.issues)
            : contractData.issues || [],
          suggestedClauses: typeof contractData.suggestedClauses === 'string'
            ? JSON.parse(contractData.suggestedClauses)
            : contractData.suggestedClauses || [],
          status: contractData.status,
          metadata: contractData.metadata || { pageCount: contractData.numPages || 1, createdAt: new Date(), updatedAt: new Date() },
          fileName: contractData.fileName
        };
        
        setContract(transformedContract);
      }
    } catch (error) {
      console.error('Error checking contract status:', error);
      // Não definimos o erro aqui para não interromper a interface
    }
  };

  // ... existing code for handleGenerateRevision, handleStartReview, etc. ...

  if (loading) {
    return (
      <div className="p-6 space-y-4">
        <Skeleton className="h-8 w-1/3" />
        <Skeleton className="h-[600px]" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-6">
        <div className="bg-red-50 text-red-500 p-4 rounded-lg">
          <h3 className="font-semibold mb-2">Error Loading Contract</h3>
          <p>{error}</p>
        </div>
      </div>
    );
  }

  if (!contract) {
    return <div className="p-6">Contract not found</div>;
  }

  // Renderizar estado de processamento
  if (contract.status === 'processing') {
    return (
      <div className="flex flex-col h-screen">
        <div className="flex-none w-full px-4 py-4 relative">
          <div className="max-w-7xl mx-auto space-y-6 relative z-10">
            <div className="rounded-3xl p-8 sm:p-10 border border-white/10 shadow-xl bg-gradient-to-b from-indigo-950/80 to-gray-900/90">
              <div className="flex items-center gap-4 mb-6">
                <div className="h-12 w-12 rounded-full bg-blue-400/20 flex items-center justify-center">
                  <Loader2 className="h-6 w-6 text-blue-400 animate-spin" />
                </div>
                <div>
                  <h2 className="text-blue-400 text-sm font-medium">Analysis in Progress</h2>
                  <h1 className="text-white text-2xl sm:text-3xl font-bold">
                    Analyzing Your Contract
                  </h1>
                </div>
              </div>

              <div className="space-y-6">
                <p className="text-blue-50 text-lg leading-relaxed">
                  Our AI is thoroughly analyzing your contract. This process may take a few minutes. You can safely leave this page and come back later - we'll continue processing your document.
                </p>

                <div className="grid grid-cols-1 sm:grid-cols-3 gap-4 pt-4">
                  <div className="bg-gray-900/50 rounded-2xl p-4 border border-white/10">
                    <div className="text-blue-200 mb-2">Scanning Document</div>
                    <div className="text-white/90 text-sm">Extracting and processing text</div>
                  </div>
                  <div className="bg-gray-900/50 rounded-2xl p-4 border border-white/10">
                    <div className="text-blue-200 mb-2">Identifying Issues</div>
                    <div className="text-white/90 text-sm">Finding potential problems</div>
                  </div>
                  <div className="bg-gray-900/50 rounded-2xl p-4 border border-white/10">
                    <div className="text-blue-200 mb-2">Generating Suggestions</div>
                    <div className="text-white/90 text-sm">Creating improvement recommendations</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          {/* Decorative elements */}
          <div className="absolute inset-0 bg-[radial-gradient(circle_at_30%_50%,rgba(255,255,255,0.1),transparent)] pointer-events-none"></div>
          <div className="absolute bottom-0 left-0 right-0 h-16 sm:h-24 bg-gradient-to-t to-transparent pointer-events-none"></div>
        </div>
      </div>
    );
  }

  // Renderizar estado de erro
  if (contract.status === 'error') {
    return (
      <div className="flex flex-col h-screen">
        <div className="flex-none w-full px-4 py-4 relative">
          <div className="max-w-7xl mx-auto space-y-6 relative z-10">
            <div className="rounded-3xl p-8 sm:p-10 border border-red-500/20 shadow-xl bg-gradient-to-b from-red-950/80 to-gray-900/90">
              <div className="flex items-center gap-4 mb-6">
                <div className="h-12 w-12 rounded-full bg-red-400/20 flex items-center justify-center">
                  <AlertCircle className="h-6 w-6 text-red-400" />
                </div>
                <div>
                  <h2 className="text-red-400 text-sm font-medium">Analysis Error</h2>
                  <h1 className="text-white text-2xl sm:text-3xl font-bold">
                    We encountered a problem
                  </h1>
                </div>
              </div>

              <div className="space-y-6">
                <p className="text-red-50 text-lg leading-relaxed">
                  {contract.metadata?.error || 'There was an error analyzing your contract. Please try again or contact support if the problem persists.'}
                </p>

                <div className="flex gap-4">
                  <button 
                    onClick={() => {
                      // Implementar lógica para tentar novamente
                      fetch(`/api/contracts/${contract.id}/reanalyze`, { method: 'POST' })
                        .then(() => {
                          setLoading(true);
                          setTimeout(() => {
                            fetch(`/api/contracts/${contract.id}`)
                              .then(res => res.json())
                              .then(data => {
                                setContract({
                                  ...contract,
                                  status: 'processing'
                                });
                                setLoading(false);
                                checkContractStatus(contract.id);
                              })
                              .catch(err => {
                                setError('Failed to restart analysis');
                                setLoading(false);
                              });
                          }, 1000);
                        })
                        .catch(err => {
                          setError('Failed to restart analysis');
                        });
                    }}
                    className="bg-white text-red-900 px-4 py-2 rounded-md hover:bg-white/90 transition-colors"
                  >
                    Try Again
                  </button>
                  
                  <button 
                    onClick={() => router.push('/contracts')}
                    className="bg-transparent text-white border border-white/20 px-4 py-2 rounded-md hover:bg-white/10 transition-colors"
                  >
                    Back to Contracts
                  </button>
                </div>
              </div>
            </div>
          </div>
          
          {/* Decorative elements */}
          <div className="absolute inset-0 bg-[radial-gradient(circle_at_30%_50%,rgba(255,255,255,0.1),transparent)] pointer-events-none"></div>
          <div className="absolute bottom-0 left-0 right-0 h-16 sm:h-24 bg-gradient-to-t to-transparent pointer-events-none"></div>
        </div>
      </div>
    );
  }

  // Interface normal para contratos analisados
  return (
    <div className="flex flex-col h-screen">
      <div className="flex-none w-full px-4 py-4 relative">
        <div className="max-w-7xl mx-auto space-y-6 relative z-10">
          <div className="rounded-3xl p-8 sm:p-10 border border-white/10 shadow-xl bg-gradient-to-b from-indigo-950/80 to-gray-900/90">
            <div className="flex items-center gap-4 mb-6">
              <div className="h-12 w-12 rounded-full bg-green-400/20 flex items-center justify-center">
                <CheckCircle className="h-6 w-6 text-green-400" />
              </div>
              <div>
                <h2 className="text-green-400 text-sm font-medium">Contract Secured</h2>
                <h1 className="text-white text-2xl sm:text-3xl font-bold">
                  Welcome to Peace of Mind
                </h1>
              </div>
            </div>

            <div className="space-y-6">
              <p className="text-blue-50 text-lg leading-relaxed">
                Your contract has been thoroughly analyzed by our advanced AI. We've taken care of identifying and addressing all potential concerns, so you can move forward with confidence.
              </p>

              <div className="grid grid-cols-1 sm:grid-cols-3 gap-4 pt-4">
                <div className="bg-gray-900/50 rounded-2xl p-4 border border-white/10">
                  <div className="text-blue-200 mb-2">Comprehensive Analysis</div>
                  <div className="text-white/90 text-sm">Every detail reviewed with precision</div>
                </div>
                <div className="bg-gray-900/50 rounded-2xl p-4 border border-white/10">
                  <div className="text-blue-200 mb-2">Risk Assessment</div>
                  <div className="text-white/90 text-sm">Potential issues identified & resolved</div>
                </div>
                <div className="bg-gray-900/50 rounded-2xl p-4 border border-white/10">
                  <div className="text-blue-200 mb-2">Smart Suggestions</div>
                  <div className="text-white/90 text-sm">AI-powered improvements ready</div>
                </div>
              </div>
            </div>
          </div>
          
          {/* <ReviewSummary 
            contract={contract}
            onStartReview={handleStartReview}
            showReview={showReview}
          />  */}
        </div>
        
        {/* Decorative elements */}
        <div className="absolute inset-0 bg-[radial-gradient(circle_at_30%_50%,rgba(255,255,255,0.1),transparent)] pointer-events-none"></div>
        <div className="absolute bottom-0 left-0 right-0 h-16 sm:h-24 bg-gradient-to-t to-transparent pointer-events-none"></div>
      </div>
      
      <div className="flex-1 overflow-hidden">
        <NewContractContent
          contract={contract}
          isFirstIssue={contract?.status === 'under_review'}
          onUpgrade={handleGenerateRevision}
          selectedIssue={null}
          onIssueClick={() => {}}
          onNext={() => {}}
          onClose={() => {}}
        />
      </div>
    </div>
  );
}
```

Esta implementação:

1. Mantém toda a interface existente intacta
2. Adiciona verificação periódica do status para contratos em processamento
3. Adiciona telas específicas para os estados "processing" e "error" que seguem o mesmo estilo visual da interface existente
4. Inclui um botão "Try Again" para casos de erro, que pode ser conectado a um endpoint para recolocar o contrato na fila

Você precisará implementar o endpoint `/api/contracts/[id]/reanalyze` para a funcionalidade de tentar novamente.

---

_**User**_

o @UploadZone.tsx ou @ContractUploader.tsx precisam atualizar estes status?

---

_**Assistant**_



Sim, os componentes de upload precisam ser atualizados para trabalhar com os novos status de processamento. Vou mostrar as alterações necessárias para ambos os componentes.

## 1. Atualização do UploadZone.tsx

```typescript:src/components/contracts/upload/UploadZone.tsx
// ... existing code ...

const waitForAnalysis = async (contractId: string) => {
  let attempts = 0;
  const maxAttempts = 60; // 2 minutos máximo (com 1s de intervalo)
  
  const checkStatus = async (): Promise<boolean> => {
    try {
      const response = await fetch(`/api/contracts/${contractId}/status`);
      const data = await response.json();
      
      // Verificar se a análise foi concluída com sucesso
      if (data.status === 'under_review' && 
          Array.isArray(data.issues) && 
          data.issues.length > 0) {
        
        // Progresso final mais suave e gradual
        const finalProgress = Math.max(progress, 90);
        for (let p = finalProgress; p <= 100; p += 0.5) {
          setProgress(p);
          await new Promise(resolve => setTimeout(resolve, 50));
        }
        
        toast.success('Contract analyzed successfully!');
        await new Promise(resolve => setTimeout(resolve, 1000));
        router.push(`/contracts/${contractId}`);
        return true;
      }
      
      switch (data.status) {
        case 'processing': // Novo status para processamento em fila
          // Progresso mais gradual durante a análise (35-90%)
          const currentProgress = progress;
          const targetProgress = Math.min(90, 35 + (attempts * 1)); // Aumenta 1% por tentativa
          
          // Garantir que o progresso nunca diminua
          if (targetProgress > currentProgress) {
            setProgress(targetProgress);
          }
          return false;
          
        case 'error':
          throw new Error(data.metadata?.error || 'Contract analysis failed');
          
        case 'under_review':
          // Caso a análise tenha sido concluída mas não tenha issues (raro)
          setProgress(100);
          toast.success('Contract analyzed successfully!');
          await new Promise(resolve => setTimeout(resolve, 1000));
          router.push(`/contracts/${contractId}`);
          return true;
          
        default:
          return false;
      }
    } catch (error) {
      console.error('Status check error:', error);
      setError('Failed to process contract');
      setLoading(false);
      setShowProcessing(false);
      return true;
    }
  };

  while (attempts < maxAttempts) {
    const isDone = await checkStatus();
    if (isDone) break;
    
    await new Promise(resolve => setTimeout(resolve, 1000));
    attempts++;
  }

  if (attempts >= maxAttempts) {
    // Se atingir o tempo máximo, redirecionar para a página do contrato
    // onde o usuário poderá ver o status atual
    toast.info('Analysis is taking longer than expected. You can check the status on the contract page.');
    router.push(`/contracts/${contractId}`);
  }
};

// ... rest of the existing code ...
```

## 2. Atualização do ContractUploader.tsx

```typescript:src/components/contracts/upload/ContractUploader.tsx
// ... existing code ...

const waitForAnalysis = async (contractId: string) => {
  let attempts = 0;
  const maxAttempts = 150; // 5 minutos (com 2s de intervalo)
  
  const checkStatus = async (): Promise<boolean> => {
    try {
      const response = await fetch(`/api/contracts/${contractId}/status`);
      const data = await response.json();
      
      switch (data.status) {
        case 'processing': // Atualizado para o novo status
          setProgress(`Analyzing contract... (${Math.round((attempts/150) * 100)}%)`);
          return false;
          
        case 'under_review':
          setProgress('Analysis complete!');
          router.push(`/contracts/${contractId}`);
          return true;
          
        case 'error':
          throw new Error(data.metadata?.error || 'Contract analysis failed');
          
        default:
          return false;
      }
    } catch (error) {
      console.error('Status check error:', error);
      setError(error instanceof Error ? error.message : 'Failed to process contract');
      setUploading(false);
      return true;
    }
  };

  while (attempts < maxAttempts) {
    const isDone = await checkStatus();
    if (isDone) break;
    
    await new Promise(resolve => setTimeout(resolve, 2000));
    attempts++;
  }

  if (attempts >= maxAttempts) {
    setError('Analysis is taking longer than expected. You can check the status later.');
    router.push(`/contracts/${contractId}`);
  }
};

// ... rest of the existing code ...
```

## 3. Implementação do endpoint para reanalizar contratos

Também precisamos implementar o endpoint para reanalizar contratos que falharam:

```typescript:src/app/api/contracts/[id]/reanalyze/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { redis, ANALYSIS_QUEUE } from '@/lib/redis';

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const contractId = params.id;
    
    // Buscar o contrato
    const contract = await prisma.contract.findUnique({
      where: { id: contractId },
      select: {
        id: true,
        userId: true,
        content: true,
        pdfPositions: true,
        status: true
      }
    });
    
    if (!contract) {
      return NextResponse.json({ error: 'Contract not found' }, { status: 404 });
    }
    
    // Verificar se o usuário tem acesso a este contrato
    if (contract.userId !== session.user.id) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }
    
    // Atualizar o status para "processing"
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'processing',
        metadata: {
          processingStartedAt: new Date(),
          reanalysisRequested: true
        }
      }
    });
    
    // Adicionar à fila de análise
    await redis.lpush(ANALYSIS_QUEUE, JSON.stringify({
      contractId,
      userId: contract.userId,
      textCoordinates: contract.pdfPositions || []
    }));
    
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Reanalysis error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
```

Estas alterações garantem que:

1. Os componentes de upload reconheçam o novo status "processing" e mostrem o progresso adequado
2. Os usuários possam reanalizar contratos que falharam
3. A interface forneça feedback apropriado durante todo o processo

Ambos os componentes agora redirecionam para a página do contrato se a análise estiver demorando muito, onde o usuário poderá ver o status atual e o progresso da análise.

---

_**User**_

nao vou precisar realisar agora.

Uma duvida, após o upload em qual momento o usuario é redirecionado para o /contracts/page

---

_**Assistant**_



Após o upload, o usuário é redirecionado para a página do contrato específico (`/contracts/[id]`) em dois momentos principais:

1. **Quando a análise é concluída com sucesso**:
   ```typescript
   if (data.status === 'under_review') {
     setProgress('Analysis complete!');
     router.push(`/contracts/${contractId}`);
     return true;
   }
   ```

2. **Quando a análise está demorando muito tempo**:
   ```typescript
   if (attempts >= maxAttempts) {
     toast.info('Analysis is taking longer than expected. You can check the status on the contract page.');
     router.push(`/contracts/${contractId}`);
   }
   ```

O usuário **não** é redirecionado para a página de listagem de contratos (`/contracts`) após o upload. Ele é sempre levado diretamente para a página do contrato específico que acabou de enviar, onde poderá ver o status da análise (processando, concluída ou com erro).

Se você quiser que o usuário seja redirecionado para a página de listagem de contratos (`/contracts`) em algum momento específico, podemos modificar essa lógica. Você gostaria de fazer essa alteração?

---

_**User**_

certo! Obg

---

_**Assistant**_



De nada! Fico feliz em ter ajudado a implementar a solução de fila para análise de contratos.

Resumindo o que implementamos:

1. **Sistema de fila com Upstash Redis** para processar análises de contratos em segundo plano
2. **Novos status de contrato** (`processing` e `error`) para rastrear o progresso da análise
3. **Verificação periódica de status** para atualizar a interface do usuário em tempo real
4. **Tratamento de erros** e opção para tentar novamente quando a análise falha
5. **Feedback visual** para o usuário durante todo o processo

Esta solução resolve o problema de timeout em funções serverless do Vercel, permitindo que análises complexas de contratos sejam executadas sem interromper a experiência do usuário.

Se precisar de mais ajustes ou tiver outras dúvidas no futuro, estou à disposição!

---

_**User**_

o que seria essse erro no upload?

---

_**Assistant**_



O erro que você está enfrentando é um problema de restrição de verificação (check constraint) no banco de dados PostgreSQL. Especificamente, o erro ocorre quando tentamos atualizar o status do contrato para "error", mas esse valor não é permitido pela restrição `contract_status_check` na tabela `Contract`.

## Problema

A mensagem de erro indica:
```
"new row for relation \"Contract\" violates check constraint \"contract_status_check\""
```

Isso significa que o valor "error" que estamos tentando definir para o campo `status` não é um dos valores permitidos pela restrição de verificação definida no banco de dados.

## Causa

No seu schema Prisma, você tem dois enums relacionados ao status do contrato:

1. `Status` - que inclui `draft`, `under_review`, `approved`, `rejected`
2. `contract_status` - que inclui os mesmos valores mais `processing` e `error`

No entanto, parece que a coluna `status` na tabela `Contract` está usando a restrição baseada no enum `Status` e não no `contract_status`, então ela não aceita os valores `processing` e `error`.

## Solução

Você precisa atualizar o schema do banco de dados para permitir os novos valores de status. Há duas abordagens:

### Opção 1: Atualizar o enum Status no schema Prisma

```prisma:prisma/schema.prisma
enum Status {
  draft
  under_review
  approved
  rejected
  processing  // Adicionar novo status
  error       // Adicionar novo status
}
```

### Opção 2: Modificar a definição da coluna status na tabela Contract

```prisma:prisma/schema.prisma
model Contract {
  // ... outros campos
  status     String   // Mudar de Status para String ou para contract_status
  // ... outros campos
}
```

Depois de fazer uma dessas alterações, você precisará executar uma migração do Prisma:

```bash
npx prisma migrate dev --name add_new_status_values
```

Se você estiver em produção e não puder fazer uma migração completa, pode modificar diretamente a restrição no PostgreSQL:

```sql
ALTER TABLE "Contract" DROP CONSTRAINT "contract_status_check";
ALTER TABLE "Contract" ADD CONSTRAINT "contract_status_check" 
  CHECK (status IN ('draft', 'under_review', 'approved', 'rejected', 'processing', 'error'));
```

## Solução temporária

Se você precisar de uma solução rápida sem alterar o schema, você pode modificar o código para usar um dos status existentes como fallback:

```typescript:src/lib/process.ts
// Em vez de:
status: 'error',

// Use:
status: 'draft', // ou outro status válido
metadata: {
  ...JSON.parse((contract?.metadata as string) || '{}'),
  actualStatus: 'error', // Armazenar o status real nos metadados
  error: error instanceof Error ? error.message : 'Analysis failed',
  errorAt: new Date()
}
```

Isso permitirá que você continue usando o sistema enquanto planeja uma migração adequada do banco de dados.

---

_**User**_

agora este erro.

---

_**Assistant**_



Exatamente como suspeitei! O erro confirma que o banco de dados não aceita os novos valores de status (`processing` e `error`) que estamos tentando usar.

## Solução Rápida

Vamos modificar o arquivo `src/lib/process.ts` para usar valores de status que já são aceitos pelo banco de dados:

```typescript:src/lib/process.ts
// ... existing code ...

export async function processContractInBackground(
  contractId: string, 
  file: File, 
  userId: string
) {
  try {
    // ... existing code ...

    // 3. Atualização: URL do arquivo, conteúdo e status
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        fileUrl: publicUrl,
        content: text,
        numPages: numPages,
        status: "draft", // Usar "draft" em vez de "processing"
        metadata: {
          pageCount: numPages,
          processingStartedAt: new Date(),
          actualStatus: "processing" // Armazenar o status real nos metadados
        }
      }
    });

    // ... rest of the function ...
  } catch (error) {
    // ... error handling ...
  }
}

export async function processQueueItem(item: { 
  contractId: string, 
  userId: string,
  textCoordinates: any[]
}) {
  const { contractId, textCoordinates } = item;
  
  try {
    // ... existing code ...
    
    // Atualizar o contrato com os resultados
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        issues: JSON.parse(JSON.stringify(analysisResult.issues)),
        suggestedClauses: JSON.parse(JSON.stringify(analysisResult.suggestedClauses)),
        status: "under_review", // Este valor já é aceito
        metadata: {
          ...JSON.parse(contract.metadata as string),
          analysisCompletedAt: new Date(),
          actualStatus: "completed" // Opcional: armazenar status real
        }
      }
    });
    
    return { success: true, contractId };
  } catch (error) {
    console.error('Queue processing error:', error);
    
    // Atualizar contrato com erro
    await prisma.contract.update({
      where: { id: contractId },
      data: {
        status: 'draft', // Usar "draft" em vez de "error"
        metadata: {
          ...JSON.parse((contract?.metadata as string) || '{}'),
          error: error instanceof Error ? error.message : 'Analysis failed',
          errorAt: new Date(),
          actualStatus: "error" // Armazenar o status real nos metadados
        }
      }
    });
    
    throw error;
  }
}
```

## Atualização do endpoint de status

Também precisamos atualizar o endpoint de status para verificar o status real nos metadados:

```typescript:src/app/api/contracts/[id]/status/route.ts
// ... existing code ...

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // ... existing code ...
    
    // Verificar o status real nos metadados
    let actualStatus = contract.status;
    if (contract.metadata && typeof contract.metadata === 'object') {
      if (contract.metadata.actualStatus === 'processing') {
        actualStatus = 'processing';
      } else if (contract.metadata.actualStatus === 'error') {
        actualStatus = 'error';
      }
    }
    
    return NextResponse.json({
      id: contract.id,
      status: actualStatus, // Usar o status real
      metadata: contract.metadata,
      isComplete: actualStatus === 'under_review' || actualStatus === 'error',
      hasResults: contract.issues.length > 0 || contract.suggestedClauses.length > 0
    });
  } catch (error) {
    // ... error handling ...
  }
}
```

## Atualização da página do contrato

Também precisamos atualizar a verificação de status na página do contrato:

```typescript:src/app/(protected)/contracts/[id]/page.tsx
// ... existing code ...

// Verificar se o contrato está em processamento
const isProcessing = contract?.status === 'draft' && 
                    contract?.metadata?.actualStatus === 'processing';

// Verificar se houve erro
const hasError = contract?.status === 'draft' && 
                contract?.metadata?.actualStatus === 'error';

// Usar estas variáveis para renderização condicional
if (isProcessing) {
  // Renderizar tela de processamento
}

if (hasError) {
  // Renderizar tela de erro
}

// ... rest of the code ...
```

## Solução Permanente

Para uma solução permanente, você deve atualizar seu schema Prisma para incluir os novos valores de status. Crie um novo arquivo de migração:

```prisma:prisma/migrations/add_new_status_values/migration.sql
-- AlterEnum
ALTER TYPE "Status" ADD VALUE 'processing';
ALTER TYPE "Status" ADD VALUE 'error';
```

E execute:

```bash
npx prisma migrate dev
```

Ou, se preferir fazer manualmente no banco de dados:

```sql
ALTER TYPE "Status" ADD VALUE 'processing';
ALTER TYPE "Status" ADD VALUE 'error';
```

Depois de atualizar o schema, você poderá usar os novos valores de status diretamente, sem precisar armazená-los nos metadados.

---



---

